// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.GLFW
{
	#if NET5_0_OR_GREATER
	/// <summary>
	/// The memory allocation function.  See <br/>
	/// for details about<br/>
	/// allocation function.<br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "allocate")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void* Allocate([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] void* user);

	#else
	/// <summary>
	/// The memory allocation function.  See <br/>
	/// for details about<br/>
	/// allocation function.<br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "allocate")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate nint Allocate([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] nint user);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// The memory reallocation function.  See <br/>
	/// for details about<br/>
	/// reallocation function.<br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "reallocate")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void* Reallocate([NativeName(NativeNameType.Param, "block")] [NativeName(NativeNameType.Type, "void*")] void* block, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] void* user);

	#else
	/// <summary>
	/// The memory reallocation function.  See <br/>
	/// for details about<br/>
	/// reallocation function.<br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "reallocate")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate nint Reallocate([NativeName(NativeNameType.Param, "block")] [NativeName(NativeNameType.Type, "void*")] nint block, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] nint user);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// The memory deallocation function.  See <br/>
	/// for details about<br/>
	/// deallocation function.<br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "deallocate")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void Deallocate([NativeName(NativeNameType.Param, "block")] [NativeName(NativeNameType.Type, "void*")] void* block, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] void* user);

	#else
	/// <summary>
	/// The memory deallocation function.  See <br/>
	/// for details about<br/>
	/// deallocation function.<br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "deallocate")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void Deallocate([NativeName(NativeNameType.Param, "block")] [NativeName(NativeNameType.Type, "void*")] nint block, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] nint user);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// Generic function pointer used for returning client API function pointers<br/>
	/// without forcing a cast from a regular pointer.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWglproc")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWglproc();

	#else
	/// <summary>
	/// <br/>
	/// Generic function pointer used for returning client API function pointers<br/>
	/// without forcing a cast from a regular pointer.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWglproc")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWglproc();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// Generic function pointer used for returning Vulkan API function pointers<br/>
	/// without forcing a cast from a regular pointer.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWvkproc")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWvkproc();

	#else
	/// <summary>
	/// <br/>
	/// Generic function pointer used for returning Vulkan API function pointers<br/>
	/// without forcing a cast from a regular pointer.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWvkproc")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWvkproc();

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for memory allocation callbacks.  A memory<br/>
	/// allocation callback function has the following signature:<br/>
	/// <br/>
	/// This function must return either a memory block at least `size` bytes long,<br/>
	/// or `NULL` if allocation failed.  Note that not all parts of GLFW handle allocation<br/>
	/// failures gracefully yet.<br/>
	/// This function must support being called during <br/>
	/// but before the library is<br/>
	/// flagged as initialized, as well as during <br/>
	/// after the library is no<br/>
	/// longer flagged as initialized.<br/>
	/// Any memory allocated via this function will be deallocated via the same allocator<br/>
	/// during library termination or earlier.<br/>
	/// Any memory allocated via this function must be suitably aligned for any object type.<br/>
	/// If you are using C99 or earlier, this alignment is platform-dependent but will be the<br/>
	/// same as what `malloc` provides.  If you are using C11 or later, this is the value of<br/>
	/// `alignof(max_align_t)`.<br/>
	/// The size will always be greater than zero.  Allocations of size zero are filtered out<br/>
	/// before reaching the custom allocator.<br/>
	/// If this function returns `NULL`, GLFW will emit <br/>
	/// This function must not call any GLFW function.<br/>
	/// <br/>
	/// <br/>
	/// _lifetime The returned memory block must be valid at least until it<br/>
	/// is deallocated.<br/>
	/// <br/>
	/// This function should not call any GLFW function.<br/>
	/// <br/>
	/// _safety This function must support being called from any thread that calls GLFW<br/>
	/// functions.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWallocatefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void* GLFWallocatefun([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] void* user);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for memory allocation callbacks.  A memory<br/>
	/// allocation callback function has the following signature:<br/>
	/// <br/>
	/// This function must return either a memory block at least `size` bytes long,<br/>
	/// or `NULL` if allocation failed.  Note that not all parts of GLFW handle allocation<br/>
	/// failures gracefully yet.<br/>
	/// This function must support being called during <br/>
	/// but before the library is<br/>
	/// flagged as initialized, as well as during <br/>
	/// after the library is no<br/>
	/// longer flagged as initialized.<br/>
	/// Any memory allocated via this function will be deallocated via the same allocator<br/>
	/// during library termination or earlier.<br/>
	/// Any memory allocated via this function must be suitably aligned for any object type.<br/>
	/// If you are using C99 or earlier, this alignment is platform-dependent but will be the<br/>
	/// same as what `malloc` provides.  If you are using C11 or later, this is the value of<br/>
	/// `alignof(max_align_t)`.<br/>
	/// The size will always be greater than zero.  Allocations of size zero are filtered out<br/>
	/// before reaching the custom allocator.<br/>
	/// If this function returns `NULL`, GLFW will emit <br/>
	/// This function must not call any GLFW function.<br/>
	/// <br/>
	/// <br/>
	/// _lifetime The returned memory block must be valid at least until it<br/>
	/// is deallocated.<br/>
	/// <br/>
	/// This function should not call any GLFW function.<br/>
	/// <br/>
	/// _safety This function must support being called from any thread that calls GLFW<br/>
	/// functions.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWallocatefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate nint GLFWallocatefun([NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] nint user);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for memory reallocation callbacks.<br/>
	/// A memory reallocation callback function has the following signature:<br/>
	/// <br/>
	/// This function must return a memory block at least `size` bytes long, or<br/>
	/// `NULL` if allocation failed.  Note that not all parts of GLFW handle allocation<br/>
	/// failures gracefully yet.<br/>
	/// This function must support being called during <br/>
	/// but before the library is<br/>
	/// flagged as initialized, as well as during <br/>
	/// after the library is no<br/>
	/// longer flagged as initialized.<br/>
	/// Any memory allocated via this function will be deallocated via the same allocator<br/>
	/// during library termination or earlier.<br/>
	/// Any memory allocated via this function must be suitably aligned for any object type.<br/>
	/// If you are using C99 or earlier, this alignment is platform-dependent but will be the<br/>
	/// same as what `realloc` provides.  If you are using C11 or later, this is the value of<br/>
	/// `alignof(max_align_t)`.<br/>
	/// The block address will never be `NULL` and the size will always be greater than zero.<br/>
	/// Reallocations of a block to size zero are converted into deallocations before reaching<br/>
	/// the custom allocator.  Reallocations of `NULL` to a non-zero size are converted into<br/>
	/// regular allocations before reaching the custom allocator.<br/>
	/// If this function returns `NULL`, GLFW will emit <br/>
	/// This function must not call any GLFW function.<br/>
	/// <br/>
	/// <br/>
	/// _lifetime The returned memory block must be valid at least until it<br/>
	/// is deallocated.<br/>
	/// <br/>
	/// This function should not call any GLFW function.<br/>
	/// <br/>
	/// _safety This function must support being called from any thread that calls GLFW<br/>
	/// functions.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWreallocatefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void* GLFWreallocatefun([NativeName(NativeNameType.Param, "block")] [NativeName(NativeNameType.Type, "void*")] void* block, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] void* user);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for memory reallocation callbacks.<br/>
	/// A memory reallocation callback function has the following signature:<br/>
	/// <br/>
	/// This function must return a memory block at least `size` bytes long, or<br/>
	/// `NULL` if allocation failed.  Note that not all parts of GLFW handle allocation<br/>
	/// failures gracefully yet.<br/>
	/// This function must support being called during <br/>
	/// but before the library is<br/>
	/// flagged as initialized, as well as during <br/>
	/// after the library is no<br/>
	/// longer flagged as initialized.<br/>
	/// Any memory allocated via this function will be deallocated via the same allocator<br/>
	/// during library termination or earlier.<br/>
	/// Any memory allocated via this function must be suitably aligned for any object type.<br/>
	/// If you are using C99 or earlier, this alignment is platform-dependent but will be the<br/>
	/// same as what `realloc` provides.  If you are using C11 or later, this is the value of<br/>
	/// `alignof(max_align_t)`.<br/>
	/// The block address will never be `NULL` and the size will always be greater than zero.<br/>
	/// Reallocations of a block to size zero are converted into deallocations before reaching<br/>
	/// the custom allocator.  Reallocations of `NULL` to a non-zero size are converted into<br/>
	/// regular allocations before reaching the custom allocator.<br/>
	/// If this function returns `NULL`, GLFW will emit <br/>
	/// This function must not call any GLFW function.<br/>
	/// <br/>
	/// <br/>
	/// _lifetime The returned memory block must be valid at least until it<br/>
	/// is deallocated.<br/>
	/// <br/>
	/// This function should not call any GLFW function.<br/>
	/// <br/>
	/// _safety This function must support being called from any thread that calls GLFW<br/>
	/// functions.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWreallocatefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate nint GLFWreallocatefun([NativeName(NativeNameType.Param, "block")] [NativeName(NativeNameType.Type, "void*")] nint block, [NativeName(NativeNameType.Param, "size")] [NativeName(NativeNameType.Type, "size_t")] ulong size, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] nint user);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for memory deallocation callbacks.<br/>
	/// A memory deallocation callback function has the following signature:<br/>
	/// <br/>
	/// This function may deallocate the specified memory block.  This memory block<br/>
	/// will have been allocated with the same allocator.<br/>
	/// This function must support being called during <br/>
	/// but before the library is<br/>
	/// flagged as initialized, as well as during <br/>
	/// after the library is no<br/>
	/// longer flagged as initialized.<br/>
	/// The block address will never be `NULL`.  Deallocations of `NULL` are filtered out<br/>
	/// before reaching the custom allocator.<br/>
	/// If this function returns `NULL`, GLFW will emit <br/>
	/// This function must not call any GLFW function.<br/>
	/// <br/>
	/// <br/>
	/// _lifetime The specified memory block will not be accessed by GLFW<br/>
	/// after this function is called.<br/>
	/// <br/>
	/// This function should not call any GLFW function.<br/>
	/// <br/>
	/// _safety This function must support being called from any thread that calls GLFW<br/>
	/// functions.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWdeallocatefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWdeallocatefun([NativeName(NativeNameType.Param, "block")] [NativeName(NativeNameType.Type, "void*")] void* block, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] void* user);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for memory deallocation callbacks.<br/>
	/// A memory deallocation callback function has the following signature:<br/>
	/// <br/>
	/// This function may deallocate the specified memory block.  This memory block<br/>
	/// will have been allocated with the same allocator.<br/>
	/// This function must support being called during <br/>
	/// but before the library is<br/>
	/// flagged as initialized, as well as during <br/>
	/// after the library is no<br/>
	/// longer flagged as initialized.<br/>
	/// The block address will never be `NULL`.  Deallocations of `NULL` are filtered out<br/>
	/// before reaching the custom allocator.<br/>
	/// If this function returns `NULL`, GLFW will emit <br/>
	/// This function must not call any GLFW function.<br/>
	/// <br/>
	/// <br/>
	/// _lifetime The specified memory block will not be accessed by GLFW<br/>
	/// after this function is called.<br/>
	/// <br/>
	/// This function should not call any GLFW function.<br/>
	/// <br/>
	/// _safety This function must support being called from any thread that calls GLFW<br/>
	/// functions.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWdeallocatefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWdeallocatefun([NativeName(NativeNameType.Param, "block")] [NativeName(NativeNameType.Type, "void*")] nint block, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void*")] nint user);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for error callbacks.  An error callback<br/>
	/// function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// _lifetime The error description string is valid until the callback<br/>
	/// function returns.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWerrorfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWerrorfun([NativeName(NativeNameType.Param, "error_code")] [NativeName(NativeNameType.Type, "int")] int errorCode, [NativeName(NativeNameType.Param, "description")] [NativeName(NativeNameType.Type, "const char*")] byte* description);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for error callbacks.  An error callback<br/>
	/// function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// _lifetime The error description string is valid until the callback<br/>
	/// function returns.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWerrorfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWerrorfun([NativeName(NativeNameType.Param, "error_code")] [NativeName(NativeNameType.Type, "int")] int errorCode, [NativeName(NativeNameType.Param, "description")] [NativeName(NativeNameType.Type, "const char*")] nint description);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window position callbacks.  A window<br/>
	/// position callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowposfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowposfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "xpos")] [NativeName(NativeNameType.Type, "int")] int xpos, [NativeName(NativeNameType.Param, "ypos")] [NativeName(NativeNameType.Type, "int")] int ypos);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window position callbacks.  A window<br/>
	/// position callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowposfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowposfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "xpos")] [NativeName(NativeNameType.Type, "int")] int xpos, [NativeName(NativeNameType.Param, "ypos")] [NativeName(NativeNameType.Type, "int")] int ypos);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window size callbacks.  A window size<br/>
	/// callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowsizefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowsizefun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window size callbacks.  A window size<br/>
	/// callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowsizefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowsizefun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window close callbacks.  A window<br/>
	/// close callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowclosefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowclosefun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window close callbacks.  A window<br/>
	/// close callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowclosefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowclosefun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window content refresh callbacks.<br/>
	/// A window content refresh callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowrefreshfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowrefreshfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window content refresh callbacks.<br/>
	/// A window content refresh callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowrefreshfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowrefreshfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window focus callbacks.  A window<br/>
	/// focus callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowfocusfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowfocusfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "focused")] [NativeName(NativeNameType.Type, "int")] int focused);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window focus callbacks.  A window<br/>
	/// focus callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowfocusfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowfocusfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "focused")] [NativeName(NativeNameType.Type, "int")] int focused);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window iconify callbacks.  A window<br/>
	/// iconify callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowiconifyfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowiconifyfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "iconified")] [NativeName(NativeNameType.Type, "int")] int iconified);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window iconify callbacks.  A window<br/>
	/// iconify callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowiconifyfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowiconifyfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "iconified")] [NativeName(NativeNameType.Type, "int")] int iconified);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window maximize callbacks.  A window<br/>
	/// maximize callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowmaximizefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowmaximizefun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "maximized")] [NativeName(NativeNameType.Type, "int")] int maximized);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window maximize callbacks.  A window<br/>
	/// maximize callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowmaximizefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowmaximizefun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "maximized")] [NativeName(NativeNameType.Type, "int")] int maximized);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for framebuffer size callbacks.<br/>
	/// A framebuffer size callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWframebuffersizefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWframebuffersizefun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for framebuffer size callbacks.<br/>
	/// A framebuffer size callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWframebuffersizefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWframebuffersizefun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "width")] [NativeName(NativeNameType.Type, "int")] int width, [NativeName(NativeNameType.Param, "height")] [NativeName(NativeNameType.Type, "int")] int height);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window content scale callbacks.<br/>
	/// A window content scale callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowcontentscalefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowcontentscalefun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "xscale")] [NativeName(NativeNameType.Type, "float")] float xscale, [NativeName(NativeNameType.Param, "yscale")] [NativeName(NativeNameType.Type, "float")] float yscale);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for window content scale callbacks.<br/>
	/// A window content scale callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWwindowcontentscalefun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWwindowcontentscalefun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "xscale")] [NativeName(NativeNameType.Type, "float")] float xscale, [NativeName(NativeNameType.Param, "yscale")] [NativeName(NativeNameType.Type, "float")] float yscale);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for mouse button callback functions.<br/>
	/// A mouse button callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWmousebuttonfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWmousebuttonfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "int")] int action, [NativeName(NativeNameType.Param, "mods")] [NativeName(NativeNameType.Type, "int")] int mods);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for mouse button callback functions.<br/>
	/// A mouse button callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWmousebuttonfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWmousebuttonfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "button")] [NativeName(NativeNameType.Type, "int")] int button, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "int")] int action, [NativeName(NativeNameType.Param, "mods")] [NativeName(NativeNameType.Type, "int")] int mods);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for cursor position callbacks.  A cursor<br/>
	/// position callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWcursorposfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWcursorposfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "xpos")] [NativeName(NativeNameType.Type, "double")] double xpos, [NativeName(NativeNameType.Param, "ypos")] [NativeName(NativeNameType.Type, "double")] double ypos);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for cursor position callbacks.  A cursor<br/>
	/// position callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWcursorposfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWcursorposfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "xpos")] [NativeName(NativeNameType.Type, "double")] double xpos, [NativeName(NativeNameType.Param, "ypos")] [NativeName(NativeNameType.Type, "double")] double ypos);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for cursor enter/leave callbacks.<br/>
	/// A cursor enter/leave callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWcursorenterfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWcursorenterfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "entered")] [NativeName(NativeNameType.Type, "int")] int entered);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for cursor enter/leave callbacks.<br/>
	/// A cursor enter/leave callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWcursorenterfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWcursorenterfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "entered")] [NativeName(NativeNameType.Type, "int")] int entered);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for scroll callbacks.  A scroll callback<br/>
	/// function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWscrollfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWscrollfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "xoffset")] [NativeName(NativeNameType.Type, "double")] double xoffset, [NativeName(NativeNameType.Param, "yoffset")] [NativeName(NativeNameType.Type, "double")] double yoffset);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for scroll callbacks.  A scroll callback<br/>
	/// function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWscrollfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWscrollfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "xoffset")] [NativeName(NativeNameType.Type, "double")] double xoffset, [NativeName(NativeNameType.Param, "yoffset")] [NativeName(NativeNameType.Type, "double")] double yoffset);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for keyboard key callbacks.  A keyboard<br/>
	/// key callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWkeyfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWkeyfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key, [NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "int")] int scancode, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "int")] int action, [NativeName(NativeNameType.Param, "mods")] [NativeName(NativeNameType.Type, "int")] int mods);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for keyboard key callbacks.  A keyboard<br/>
	/// key callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWkeyfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWkeyfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "key")] [NativeName(NativeNameType.Type, "int")] int key, [NativeName(NativeNameType.Param, "scancode")] [NativeName(NativeNameType.Type, "int")] int scancode, [NativeName(NativeNameType.Param, "action")] [NativeName(NativeNameType.Type, "int")] int action, [NativeName(NativeNameType.Param, "mods")] [NativeName(NativeNameType.Type, "int")] int mods);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for Unicode character callbacks.<br/>
	/// A Unicode character callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWcharfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWcharfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "unsigned int")] uint codepoint);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for Unicode character callbacks.<br/>
	/// A Unicode character callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWcharfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWcharfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "unsigned int")] uint codepoint);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for Unicode character with modifiers<br/>
	/// callbacks.  It is called for each input character, regardless of what<br/>
	/// modifier keys are held down.  A Unicode character with modifiers callback<br/>
	/// function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWcharmodsfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWcharmodsfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "unsigned int")] uint codepoint, [NativeName(NativeNameType.Param, "mods")] [NativeName(NativeNameType.Type, "int")] int mods);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for Unicode character with modifiers<br/>
	/// callbacks.  It is called for each input character, regardless of what<br/>
	/// modifier keys are held down.  A Unicode character with modifiers callback<br/>
	/// function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWcharmodsfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWcharmodsfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "codepoint")] [NativeName(NativeNameType.Type, "unsigned int")] uint codepoint, [NativeName(NativeNameType.Param, "mods")] [NativeName(NativeNameType.Type, "int")] int mods);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for path drop callbacks.  A path drop<br/>
	/// callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// _lifetime The path array and its strings are valid until the<br/>
	/// callback function returns.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWdropfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWdropfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "path_count")] [NativeName(NativeNameType.Type, "int")] int pathCount, [NativeName(NativeNameType.Param, "paths")] [NativeName(NativeNameType.Type, "const char*[-1]")] byte** paths);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for path drop callbacks.  A path drop<br/>
	/// callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// _lifetime The path array and its strings are valid until the<br/>
	/// callback function returns.<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWdropfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWdropfun([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] nint window, [NativeName(NativeNameType.Param, "path_count")] [NativeName(NativeNameType.Type, "int")] int pathCount, [NativeName(NativeNameType.Param, "paths")] [NativeName(NativeNameType.Type, "const char*[-1]")] nint paths);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for monitor configuration callbacks.<br/>
	/// A monitor callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWmonitorfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWmonitorfun([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "GLFWmonitor*")] GLFWmonitor* monitor, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "int")] int evnt);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for monitor configuration callbacks.<br/>
	/// A monitor callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWmonitorfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWmonitorfun([NativeName(NativeNameType.Param, "monitor")] [NativeName(NativeNameType.Type, "GLFWmonitor*")] nint monitor, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "int")] int evnt);

	#endif

	#if NET5_0_OR_GREATER
	/// <summary>
	/// <br/>
	/// This is the function pointer type for joystick configuration callbacks.<br/>
	/// A joystick configuration callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWjoystickfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWjoystickfun([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "int")] int evnt);

	#else
	/// <summary>
	/// <br/>
	/// This is the function pointer type for joystick configuration callbacks.<br/>
	/// A joystick configuration callback function has the following signature:<br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.Delegate, "GLFWjoystickfun")]
	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	public unsafe delegate void GLFWjoystickfun([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "event")] [NativeName(NativeNameType.Type, "int")] int evnt);

	#endif

}
