// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.GLFW
{
	public unsafe partial class GLFW
	{

		/// <summary>
		/// <br/>
		/// This function returns the values of all axes of the specified joystick.<br/>
		/// Each element in the array is a value between -1.0 and 1.0.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickAxes")]
		[return: NativeName(NativeNameType.Type, "const float*")]
		public static float* GetJoystickAxes([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] int* count)
		{
			float* ret = GetJoystickAxesNative(jid, count);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the values of all axes of the specified joystick.<br/>
		/// Each element in the array is a value between -1.0 and 1.0.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickAxes")]
		[return: NativeName(NativeNameType.Type, "const float*")]
		public static float* GetJoystickAxes([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				float* ret = GetJoystickAxesNative(jid, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the state of all buttons of the specified joystick.<br/>
		/// Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.<br/>
		/// For backward compatibility with earlier versions that did not have <br/>
		/// the button array also includes all hats, each<br/>
		/// represented as four buttons.  The hats are in the same order as returned by<br/>
		/// __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and<br/>
		/// _left_.  To disable these extra buttons, set the <br/>
		/// init hint before initialization.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickButtons")]
		[return: NativeName(NativeNameType.Type, "const unsigned char*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickButtonsNative([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int*, byte*>)funcTable[95])(jid, count);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint, nint>)funcTable[95])(jid, (nint)count);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the state of all buttons of the specified joystick.<br/>
		/// Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.<br/>
		/// For backward compatibility with earlier versions that did not have <br/>
		/// the button array also includes all hats, each<br/>
		/// represented as four buttons.  The hats are in the same order as returned by<br/>
		/// __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and<br/>
		/// _left_.  To disable these extra buttons, set the <br/>
		/// init hint before initialization.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickButtons")]
		[return: NativeName(NativeNameType.Type, "const unsigned char*")]
		public static byte* GetJoystickButtons([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] int* count)
		{
			byte* ret = GetJoystickButtonsNative(jid, count);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the state of all buttons of the specified joystick.<br/>
		/// Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.<br/>
		/// For backward compatibility with earlier versions that did not have <br/>
		/// the button array also includes all hats, each<br/>
		/// represented as four buttons.  The hats are in the same order as returned by<br/>
		/// __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and<br/>
		/// _left_.  To disable these extra buttons, set the <br/>
		/// init hint before initialization.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickButtons")]
		[return: NativeName(NativeNameType.Type, "const unsigned char*")]
		public static string GetJoystickButtonsS([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] int* count)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickButtonsNative(jid, count));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the state of all buttons of the specified joystick.<br/>
		/// Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.<br/>
		/// For backward compatibility with earlier versions that did not have <br/>
		/// the button array also includes all hats, each<br/>
		/// represented as four buttons.  The hats are in the same order as returned by<br/>
		/// __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and<br/>
		/// _left_.  To disable these extra buttons, set the <br/>
		/// init hint before initialization.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickButtons")]
		[return: NativeName(NativeNameType.Type, "const unsigned char*")]
		public static byte* GetJoystickButtons([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				byte* ret = GetJoystickButtonsNative(jid, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the state of all buttons of the specified joystick.<br/>
		/// Each element in the array is either `GLFW_PRESS` or `GLFW_RELEASE`.<br/>
		/// For backward compatibility with earlier versions that did not have <br/>
		/// the button array also includes all hats, each<br/>
		/// represented as four buttons.  The hats are in the same order as returned by<br/>
		/// __glfwGetJoystickHats__ and are in the order _up_, _right_, _down_ and<br/>
		/// _left_.  To disable these extra buttons, set the <br/>
		/// init hint before initialization.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickButtons")]
		[return: NativeName(NativeNameType.Type, "const unsigned char*")]
		public static string GetJoystickButtonsS([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				string ret = Utils.DecodeStringUTF8(GetJoystickButtonsNative(jid, (int*)pcount));
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the state of all hats of the specified joystick.<br/>
		/// Each element in the array is one of the following values:<br/>
		/// Name                  | Value<br/>
		/// ----                  | -----<br/>
		/// `GLFW_HAT_CENTERED`   | 0<br/>
		/// `GLFW_HAT_UP`         | 1<br/>
		/// `GLFW_HAT_RIGHT`      | 2<br/>
		/// `GLFW_HAT_DOWN`       | 4<br/>
		/// `GLFW_HAT_LEFT`       | 8<br/>
		/// `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_UP`<br/>
		/// `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_DOWN`<br/>
		/// `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_UP`<br/>
		/// `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_DOWN`<br/>
		/// The diagonal directions are bitwise combinations of the primary (up, right,<br/>
		/// down and left) directions and you can test for these individually by ANDing<br/>
		/// it with the corresponding direction.<br/>
		/// <br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected, this function is called again for that joystick or the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickHats")]
		[return: NativeName(NativeNameType.Type, "const unsigned char*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickHatsNative([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] int* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int*, byte*>)funcTable[96])(jid, count);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint, nint>)funcTable[96])(jid, (nint)count);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the state of all hats of the specified joystick.<br/>
		/// Each element in the array is one of the following values:<br/>
		/// Name                  | Value<br/>
		/// ----                  | -----<br/>
		/// `GLFW_HAT_CENTERED`   | 0<br/>
		/// `GLFW_HAT_UP`         | 1<br/>
		/// `GLFW_HAT_RIGHT`      | 2<br/>
		/// `GLFW_HAT_DOWN`       | 4<br/>
		/// `GLFW_HAT_LEFT`       | 8<br/>
		/// `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_UP`<br/>
		/// `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_DOWN`<br/>
		/// `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_UP`<br/>
		/// `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_DOWN`<br/>
		/// The diagonal directions are bitwise combinations of the primary (up, right,<br/>
		/// down and left) directions and you can test for these individually by ANDing<br/>
		/// it with the corresponding direction.<br/>
		/// <br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected, this function is called again for that joystick or the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickHats")]
		[return: NativeName(NativeNameType.Type, "const unsigned char*")]
		public static byte* GetJoystickHats([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] int* count)
		{
			byte* ret = GetJoystickHatsNative(jid, count);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the state of all hats of the specified joystick.<br/>
		/// Each element in the array is one of the following values:<br/>
		/// Name                  | Value<br/>
		/// ----                  | -----<br/>
		/// `GLFW_HAT_CENTERED`   | 0<br/>
		/// `GLFW_HAT_UP`         | 1<br/>
		/// `GLFW_HAT_RIGHT`      | 2<br/>
		/// `GLFW_HAT_DOWN`       | 4<br/>
		/// `GLFW_HAT_LEFT`       | 8<br/>
		/// `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_UP`<br/>
		/// `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_DOWN`<br/>
		/// `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_UP`<br/>
		/// `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_DOWN`<br/>
		/// The diagonal directions are bitwise combinations of the primary (up, right,<br/>
		/// down and left) directions and you can test for these individually by ANDing<br/>
		/// it with the corresponding direction.<br/>
		/// <br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected, this function is called again for that joystick or the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickHats")]
		[return: NativeName(NativeNameType.Type, "const unsigned char*")]
		public static string GetJoystickHatsS([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] int* count)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickHatsNative(jid, count));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the state of all hats of the specified joystick.<br/>
		/// Each element in the array is one of the following values:<br/>
		/// Name                  | Value<br/>
		/// ----                  | -----<br/>
		/// `GLFW_HAT_CENTERED`   | 0<br/>
		/// `GLFW_HAT_UP`         | 1<br/>
		/// `GLFW_HAT_RIGHT`      | 2<br/>
		/// `GLFW_HAT_DOWN`       | 4<br/>
		/// `GLFW_HAT_LEFT`       | 8<br/>
		/// `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_UP`<br/>
		/// `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_DOWN`<br/>
		/// `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_UP`<br/>
		/// `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_DOWN`<br/>
		/// The diagonal directions are bitwise combinations of the primary (up, right,<br/>
		/// down and left) directions and you can test for these individually by ANDing<br/>
		/// it with the corresponding direction.<br/>
		/// <br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected, this function is called again for that joystick or the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickHats")]
		[return: NativeName(NativeNameType.Type, "const unsigned char*")]
		public static byte* GetJoystickHats([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				byte* ret = GetJoystickHatsNative(jid, (int*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the state of all hats of the specified joystick.<br/>
		/// Each element in the array is one of the following values:<br/>
		/// Name                  | Value<br/>
		/// ----                  | -----<br/>
		/// `GLFW_HAT_CENTERED`   | 0<br/>
		/// `GLFW_HAT_UP`         | 1<br/>
		/// `GLFW_HAT_RIGHT`      | 2<br/>
		/// `GLFW_HAT_DOWN`       | 4<br/>
		/// `GLFW_HAT_LEFT`       | 8<br/>
		/// `GLFW_HAT_RIGHT_UP`   | `GLFW_HAT_RIGHT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_UP`<br/>
		/// `GLFW_HAT_RIGHT_DOWN` | `GLFW_HAT_RIGHT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_DOWN`<br/>
		/// `GLFW_HAT_LEFT_UP`    | `GLFW_HAT_LEFT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_UP`<br/>
		/// `GLFW_HAT_LEFT_DOWN`  | `GLFW_HAT_LEFT` <br/>
		/// \<br/>
		/// | `GLFW_HAT_DOWN`<br/>
		/// The diagonal directions are bitwise combinations of the primary (up, right,<br/>
		/// down and left) directions and you can test for these individually by ANDing<br/>
		/// it with the corresponding direction.<br/>
		/// <br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected, this function is called again for that joystick or the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickHats")]
		[return: NativeName(NativeNameType.Type, "const unsigned char*")]
		public static string GetJoystickHatsS([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int*")] ref int count)
		{
			fixed (int* pcount = &count)
			{
				string ret = Utils.DecodeStringUTF8(GetJoystickHatsNative(jid, (int*)pcount));
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the name, encoded as UTF-8, of the specified joystick.<br/>
		/// The returned string is allocated and freed by GLFW.  You should not free it<br/>
		/// yourself.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickNameNative([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[97])(jid);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[97])(jid);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the name, encoded as UTF-8, of the specified joystick.<br/>
		/// The returned string is allocated and freed by GLFW.  You should not free it<br/>
		/// yourself.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* GetJoystickName([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			byte* ret = GetJoystickNameNative(jid);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the name, encoded as UTF-8, of the specified joystick.<br/>
		/// The returned string is allocated and freed by GLFW.  You should not free it<br/>
		/// yourself.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string GetJoystickNameS([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickNameNative(jid));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the SDL compatible GUID, as a UTF-8 encoded<br/>
		/// hexadecimal string, of the specified joystick.  The returned string is<br/>
		/// allocated and freed by GLFW.  You should not free it yourself.<br/>
		/// The GUID is what connects a joystick to a gamepad mapping.  A connected<br/>
		/// joystick will always have a GUID even if there is no gamepad mapping<br/>
		/// assigned to it.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// The GUID uses the format introduced in SDL 2.0.5.  This GUID tries to<br/>
		/// uniquely identify the make and model of a joystick but does not identify<br/>
		/// a specific unit, e.g. all wired Xbox 360 controllers will have the same<br/>
		/// GUID on that platform.  The GUID for a unit may vary between platforms<br/>
		/// depending on what hardware information the platform specific APIs provide.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickGUID")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetJoystickGUIDNative([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[98])(jid);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[98])(jid);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the SDL compatible GUID, as a UTF-8 encoded<br/>
		/// hexadecimal string, of the specified joystick.  The returned string is<br/>
		/// allocated and freed by GLFW.  You should not free it yourself.<br/>
		/// The GUID is what connects a joystick to a gamepad mapping.  A connected<br/>
		/// joystick will always have a GUID even if there is no gamepad mapping<br/>
		/// assigned to it.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// The GUID uses the format introduced in SDL 2.0.5.  This GUID tries to<br/>
		/// uniquely identify the make and model of a joystick but does not identify<br/>
		/// a specific unit, e.g. all wired Xbox 360 controllers will have the same<br/>
		/// GUID on that platform.  The GUID for a unit may vary between platforms<br/>
		/// depending on what hardware information the platform specific APIs provide.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickGUID")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* GetJoystickGUID([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			byte* ret = GetJoystickGUIDNative(jid);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the SDL compatible GUID, as a UTF-8 encoded<br/>
		/// hexadecimal string, of the specified joystick.  The returned string is<br/>
		/// allocated and freed by GLFW.  You should not free it yourself.<br/>
		/// The GUID is what connects a joystick to a gamepad mapping.  A connected<br/>
		/// joystick will always have a GUID even if there is no gamepad mapping<br/>
		/// assigned to it.<br/>
		/// If the specified joystick is not present this function will return `NULL`<br/>
		/// but will not generate an error.  This can be used instead of first calling<br/>
		/// <br/>
		/// The GUID uses the format introduced in SDL 2.0.5.  This GUID tries to<br/>
		/// uniquely identify the make and model of a joystick but does not identify<br/>
		/// a specific unit, e.g. all wired Xbox 360 controllers will have the same<br/>
		/// GUID on that platform.  The GUID for a unit may vary between platforms<br/>
		/// depending on what hardware information the platform specific APIs provide.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickGUID")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string GetJoystickGUIDS([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			string ret = Utils.DecodeStringUTF8(GetJoystickGUIDNative(jid));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function sets the user-defined pointer of the specified joystick.  The<br/>
		/// current value is retained until the joystick is disconnected.  The initial<br/>
		/// value is `NULL`.<br/>
		/// This function may be called from the joystick callback, even for a joystick<br/>
		/// that is being disconnected.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetJoystickUserPointer")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetJoystickUserPointerNative([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "pointer")] [NativeName(NativeNameType.Type, "void*")] void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void*, void>)funcTable[99])(jid, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[99])(jid, (nint)pointer);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function sets the user-defined pointer of the specified joystick.  The<br/>
		/// current value is retained until the joystick is disconnected.  The initial<br/>
		/// value is `NULL`.<br/>
		/// This function may be called from the joystick callback, even for a joystick<br/>
		/// that is being disconnected.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetJoystickUserPointer")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetJoystickUserPointer([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "pointer")] [NativeName(NativeNameType.Type, "void*")] void* pointer)
		{
			SetJoystickUserPointerNative(jid, pointer);
		}

		/// <summary>
		/// <br/>
		/// This function returns the current value of the user-defined pointer of the<br/>
		/// specified joystick.  The initial value is `NULL`.<br/>
		/// This function may be called from the joystick callback, even for a joystick<br/>
		/// that is being disconnected.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickUserPointer")]
		[return: NativeName(NativeNameType.Type, "void*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetJoystickUserPointerNative([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, void*>)funcTable[100])(jid);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[100])(jid);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the current value of the user-defined pointer of the<br/>
		/// specified joystick.  The initial value is `NULL`.<br/>
		/// This function may be called from the joystick callback, even for a joystick<br/>
		/// that is being disconnected.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetJoystickUserPointer")]
		[return: NativeName(NativeNameType.Type, "void*")]
		public static void* GetJoystickUserPointer([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			void* ret = GetJoystickUserPointerNative(jid);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified joystick is both present and has<br/>
		/// a gamepad mapping.<br/>
		/// If the specified joystick is present but does not have a gamepad mapping<br/>
		/// this function will return `GLFW_FALSE` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check if a joystick is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwJoystickIsGamepad")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickIsGamepadNative([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[101])(jid);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[101])(jid);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified joystick is both present and has<br/>
		/// a gamepad mapping.<br/>
		/// If the specified joystick is present but does not have a gamepad mapping<br/>
		/// this function will return `GLFW_FALSE` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check if a joystick is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwJoystickIsGamepad")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int JoystickIsGamepad([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			int ret = JoystickIsGamepadNative(jid);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function sets the joystick configuration callback, or removes the<br/>
		/// currently set callback.  This is called when a joystick is connected to or<br/>
		/// disconnected from the system.<br/>
		/// For joystick connection and disconnection events to be delivered on all<br/>
		/// platforms, you need to call one of the [event processing](<br/>
		/// functions.  Joystick disconnection may also be detected and the callback<br/>
		/// called by joystick functions.  The function will then return whatever it<br/>
		/// returns if the joystick is not present.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// For more information about the callback parameters, see the<br/>
		/// [function pointer type](<br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetJoystickCallback")]
		[return: NativeName(NativeNameType.Type, "GLFWjoystickfun")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<int, int, void> SetJoystickCallbackNative([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "GLFWjoystickfun")] GLFWjoystickfun callback)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<int, int, void>, delegate*<int, int, void>>)funcTable[102])((delegate*<int, int, void>)Utils.GetFunctionPointerForDelegate(callback));
			#else
			return (delegate*<int, int, void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[102])((nint)Utils.GetFunctionPointerForDelegate(callback));
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function sets the joystick configuration callback, or removes the<br/>
		/// currently set callback.  This is called when a joystick is connected to or<br/>
		/// disconnected from the system.<br/>
		/// For joystick connection and disconnection events to be delivered on all<br/>
		/// platforms, you need to call one of the [event processing](<br/>
		/// functions.  Joystick disconnection may also be detected and the callback<br/>
		/// called by joystick functions.  The function will then return whatever it<br/>
		/// returns if the joystick is not present.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// For more information about the callback parameters, see the<br/>
		/// [function pointer type](<br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetJoystickCallback")]
		[return: NativeName(NativeNameType.Type, "GLFWjoystickfun")]
		public static delegate*<int, int, void> SetJoystickCallback([NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "GLFWjoystickfun")] GLFWjoystickfun callback)
		{
			delegate*<int, int, void> ret = SetJoystickCallbackNative(callback);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function parses the specified ASCII encoded string and updates the<br/>
		/// internal list with any gamepad mappings it finds.  This string may<br/>
		/// contain either a single gamepad mapping or many mappings separated by<br/>
		/// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`<br/>
		/// source file including empty lines and comments.<br/>
		/// See <br/>
		/// for a description of the format.<br/>
		/// If there is already a gamepad mapping for a given GUID in the internal list,<br/>
		/// it will be replaced by the one passed to this function.  If the library is<br/>
		/// terminated and re-initialized the internal list will revert to the built-in<br/>
		/// default.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwUpdateGamepadMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateGamepadMappingsNative([NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[103])(str);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[103])((nint)str);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function parses the specified ASCII encoded string and updates the<br/>
		/// internal list with any gamepad mappings it finds.  This string may<br/>
		/// contain either a single gamepad mapping or many mappings separated by<br/>
		/// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`<br/>
		/// source file including empty lines and comments.<br/>
		/// See <br/>
		/// for a description of the format.<br/>
		/// If there is already a gamepad mapping for a given GUID in the internal list,<br/>
		/// it will be replaced by the one passed to this function.  If the library is<br/>
		/// terminated and re-initialized the internal list will revert to the built-in<br/>
		/// default.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwUpdateGamepadMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateGamepadMappings([NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			int ret = UpdateGamepadMappingsNative(str);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function parses the specified ASCII encoded string and updates the<br/>
		/// internal list with any gamepad mappings it finds.  This string may<br/>
		/// contain either a single gamepad mapping or many mappings separated by<br/>
		/// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`<br/>
		/// source file including empty lines and comments.<br/>
		/// See <br/>
		/// for a description of the format.<br/>
		/// If there is already a gamepad mapping for a given GUID in the internal list,<br/>
		/// it will be replaced by the one passed to this function.  If the library is<br/>
		/// terminated and re-initialized the internal list will revert to the built-in<br/>
		/// default.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwUpdateGamepadMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateGamepadMappings([NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				int ret = UpdateGamepadMappingsNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function parses the specified ASCII encoded string and updates the<br/>
		/// internal list with any gamepad mappings it finds.  This string may<br/>
		/// contain either a single gamepad mapping or many mappings separated by<br/>
		/// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`<br/>
		/// source file including empty lines and comments.<br/>
		/// See <br/>
		/// for a description of the format.<br/>
		/// If there is already a gamepad mapping for a given GUID in the internal list,<br/>
		/// it will be replaced by the one passed to this function.  If the library is<br/>
		/// terminated and re-initialized the internal list will revert to the built-in<br/>
		/// default.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwUpdateGamepadMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateGamepadMappings([NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				int ret = UpdateGamepadMappingsNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function parses the specified ASCII encoded string and updates the<br/>
		/// internal list with any gamepad mappings it finds.  This string may<br/>
		/// contain either a single gamepad mapping or many mappings separated by<br/>
		/// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`<br/>
		/// source file including empty lines and comments.<br/>
		/// See <br/>
		/// for a description of the format.<br/>
		/// If there is already a gamepad mapping for a given GUID in the internal list,<br/>
		/// it will be replaced by the one passed to this function.  If the library is<br/>
		/// terminated and re-initialized the internal list will revert to the built-in<br/>
		/// default.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwUpdateGamepadMappings")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int UpdateGamepadMappings([NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = UpdateGamepadMappingsNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the human-readable name of the gamepad from the<br/>
		/// gamepad mapping assigned to the specified joystick.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `NULL` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected, the gamepad mappings are updated or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetGamepadName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadNameNative([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[104])(jid);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[104])(jid);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the human-readable name of the gamepad from the<br/>
		/// gamepad mapping assigned to the specified joystick.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `NULL` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected, the gamepad mappings are updated or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetGamepadName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* GetGamepadName([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			byte* ret = GetGamepadNameNative(jid);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the human-readable name of the gamepad from the<br/>
		/// gamepad mapping assigned to the specified joystick.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `NULL` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected, the gamepad mappings are updated or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetGamepadName")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string GetGamepadNameS([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadNameNative(jid));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function retrieves the state of the specified joystick remapped to<br/>
		/// an Xbox-like gamepad.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `GLFW_FALSE` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// The Guide button may not be available for input as it is often hooked by the<br/>
		/// system or the Steam client.<br/>
		/// Not all devices have all the buttons or axes provided by <br/>
		/// Unavailable buttons and axes will always report<br/>
		/// `GLFW_RELEASE` and 0.0 respectively.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetGamepadState")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGamepadStateNative([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "GLFWgamepadstate*")] GLFWgamepadstate* state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, GLFWgamepadstate*, int>)funcTable[105])(jid, state);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[105])(jid, (nint)state);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function retrieves the state of the specified joystick remapped to<br/>
		/// an Xbox-like gamepad.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `GLFW_FALSE` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// The Guide button may not be available for input as it is often hooked by the<br/>
		/// system or the Steam client.<br/>
		/// Not all devices have all the buttons or axes provided by <br/>
		/// Unavailable buttons and axes will always report<br/>
		/// `GLFW_RELEASE` and 0.0 respectively.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetGamepadState")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadState([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "GLFWgamepadstate*")] GLFWgamepadstate* state)
		{
			int ret = GetGamepadStateNative(jid, state);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function retrieves the state of the specified joystick remapped to<br/>
		/// an Xbox-like gamepad.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `GLFW_FALSE` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// The Guide button may not be available for input as it is often hooked by the<br/>
		/// system or the Steam client.<br/>
		/// Not all devices have all the buttons or axes provided by <br/>
		/// Unavailable buttons and axes will always report<br/>
		/// `GLFW_RELEASE` and 0.0 respectively.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetGamepadState")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetGamepadState([NativeName(NativeNameType.Param, "jid")] [NativeName(NativeNameType.Type, "int")] int jid, [NativeName(NativeNameType.Param, "state")] [NativeName(NativeNameType.Type, "GLFWgamepadstate*")] ref GLFWgamepadstate state)
		{
			fixed (GLFWgamepadstate* pstate = &state)
			{
				int ret = GetGamepadStateNative(jid, (GLFWgamepadstate*)pstate);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetClipboardString")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetClipboardStringNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, byte*, void>)funcTable[106])(window, str);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[106])((nint)window, (nint)str);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetClipboardString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardString([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			SetClipboardStringNative(window, str);
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetClipboardString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardString([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] ref GLFWwindow window, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] byte* str)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				SetClipboardStringNative((GLFWwindow*)pwindow, str);
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetClipboardString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardString([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				SetClipboardStringNative(window, (byte*)pstr);
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetClipboardString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardString([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SetClipboardStringNative(window, (byte*)pstr);
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetClipboardString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardString([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetClipboardStringNative(window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetClipboardString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardString([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] ref GLFWwindow window, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] ref byte str)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (byte* pstr = &str)
				{
					SetClipboardStringNative((GLFWwindow*)pwindow, (byte*)pstr);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetClipboardString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardString([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] ref GLFWwindow window, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> str)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (byte* pstr = str)
				{
					SetClipboardStringNative((GLFWwindow*)pwindow, (byte*)pstr);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetClipboardString")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetClipboardString([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] ref GLFWwindow window, [NativeName(NativeNameType.Param, "string")] [NativeName(NativeNameType.Type, "const char*")] string str)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetClipboardStringNative((GLFWwindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the contents of the system clipboard, if it contains<br/>
		/// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or<br/>
		/// if its contents cannot be converted, `NULL` is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the next call to <br/>
		/// or <br/>
		/// or until the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetClipboardString")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetClipboardStringNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, byte*>)funcTable[107])(window);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[107])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the contents of the system clipboard, if it contains<br/>
		/// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or<br/>
		/// if its contents cannot be converted, `NULL` is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the next call to <br/>
		/// or <br/>
		/// or until the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetClipboardString")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* GetClipboardString([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window)
		{
			byte* ret = GetClipboardStringNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the contents of the system clipboard, if it contains<br/>
		/// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or<br/>
		/// if its contents cannot be converted, `NULL` is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the next call to <br/>
		/// or <br/>
		/// or until the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetClipboardString")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string GetClipboardStringS([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window)
		{
			string ret = Utils.DecodeStringUTF8(GetClipboardStringNative(window));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the contents of the system clipboard, if it contains<br/>
		/// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or<br/>
		/// if its contents cannot be converted, `NULL` is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the next call to <br/>
		/// or <br/>
		/// or until the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetClipboardString")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static byte* GetClipboardString([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				byte* ret = GetClipboardStringNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the contents of the system clipboard, if it contains<br/>
		/// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or<br/>
		/// if its contents cannot be converted, `NULL` is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the next call to <br/>
		/// or <br/>
		/// or until the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetClipboardString")]
		[return: NativeName(NativeNameType.Type, "const char*")]
		public static string GetClipboardStringS([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				string ret = Utils.DecodeStringUTF8(GetClipboardStringNative((GLFWwindow*)pwindow));
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the current GLFW time, in seconds.  Unless the time<br/>
		/// has been set using <br/>
		/// it measures time elapsed since GLFW was<br/>
		/// initialized.<br/>
		/// This function and <br/>
		/// are helper functions on top of <br/>
		/// and <br/>
		/// The resolution of the timer is system dependent, but is usually on the order<br/>
		/// of a few micro- or nanoseconds.  It uses the highest-resolution monotonic<br/>
		/// time source on each operating system.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Reading and<br/>
		/// writing of the internal base time is not atomic, so it needs to be<br/>
		/// externally synchronized with calls to <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetTime")]
		[return: NativeName(NativeNameType.Type, "double")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double GetTimeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double>)funcTable[108])();
			#else
			return (double)((delegate* unmanaged[Cdecl]<double>)funcTable[108])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the current GLFW time, in seconds.  Unless the time<br/>
		/// has been set using <br/>
		/// it measures time elapsed since GLFW was<br/>
		/// initialized.<br/>
		/// This function and <br/>
		/// are helper functions on top of <br/>
		/// and <br/>
		/// The resolution of the timer is system dependent, but is usually on the order<br/>
		/// of a few micro- or nanoseconds.  It uses the highest-resolution monotonic<br/>
		/// time source on each operating system.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Reading and<br/>
		/// writing of the internal base time is not atomic, so it needs to be<br/>
		/// externally synchronized with calls to <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetTime")]
		[return: NativeName(NativeNameType.Type, "double")]
		public static double GetTime()
		{
			double ret = GetTimeNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function sets the current GLFW time, in seconds.  The value must be<br/>
		/// a positive finite number less than or equal to 18446744073.0, which is<br/>
		/// approximately 584.5 years.<br/>
		/// This function and <br/>
		/// are helper functions on top of <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Reading and<br/>
		/// writing of the internal base time is not atomic, so it needs to be<br/>
		/// externally synchronized with calls to <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetTime")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTimeNative([NativeName(NativeNameType.Param, "time")] [NativeName(NativeNameType.Type, "double")] double time)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[109])(time);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[109])(time);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function sets the current GLFW time, in seconds.  The value must be<br/>
		/// a positive finite number less than or equal to 18446744073.0, which is<br/>
		/// approximately 584.5 years.<br/>
		/// This function and <br/>
		/// are helper functions on top of <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Reading and<br/>
		/// writing of the internal base time is not atomic, so it needs to be<br/>
		/// externally synchronized with calls to <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSetTime")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTime([NativeName(NativeNameType.Param, "time")] [NativeName(NativeNameType.Type, "double")] double time)
		{
			SetTimeNative(time);
		}

		/// <summary>
		/// <br/>
		/// This function returns the current value of the raw timer, measured in<br/>
		/// 1<br/>
		/// <br/>
		/// /<br/>
		/// <br/>
		/// frequency seconds.  To get the frequency, call <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetTimerValue")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTimerValueNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[110])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[110])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the current value of the raw timer, measured in<br/>
		/// 1<br/>
		/// <br/>
		/// /<br/>
		/// <br/>
		/// frequency seconds.  To get the frequency, call <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetTimerValue")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong GetTimerValue()
		{
			ulong ret = GetTimerValueNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the frequency, in Hz, of the raw timer.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetTimerFrequency")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTimerFrequencyNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[111])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[111])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the frequency, in Hz, of the raw timer.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetTimerFrequency")]
		[return: NativeName(NativeNameType.Type, "uint64_t")]
		public static ulong GetTimerFrequency()
		{
			ulong ret = GetTimerFrequencyNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function makes the OpenGL or OpenGL ES context of the specified window<br/>
		/// current on the calling thread.  It can also detach the current context from<br/>
		/// the calling thread without making a new one current by passing in `NULL`.<br/>
		/// A context must only be made current on a single thread at a time and each<br/>
		/// thread can have only a single current context at a time.  Making a context<br/>
		/// current detaches any previously current context on the calling thread.<br/>
		/// When moving a context between threads, you must detach it (make it<br/>
		/// non-current) on the old thread before making it current on the new one.<br/>
		/// By default, making a context non-current implicitly forces a pipeline flush.<br/>
		/// On machines that support `GL_KHR_context_flush_control`, you can control<br/>
		/// whether a context performs this flush by setting the<br/>
		/// [GLFW_CONTEXT_RELEASE_BEHAVIOR](<br/>
		/// hint.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwMakeContextCurrent")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeContextCurrentNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, void>)funcTable[112])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[112])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function makes the OpenGL or OpenGL ES context of the specified window<br/>
		/// current on the calling thread.  It can also detach the current context from<br/>
		/// the calling thread without making a new one current by passing in `NULL`.<br/>
		/// A context must only be made current on a single thread at a time and each<br/>
		/// thread can have only a single current context at a time.  Making a context<br/>
		/// current detaches any previously current context on the calling thread.<br/>
		/// When moving a context between threads, you must detach it (make it<br/>
		/// non-current) on the old thread before making it current on the new one.<br/>
		/// By default, making a context non-current implicitly forces a pipeline flush.<br/>
		/// On machines that support `GL_KHR_context_flush_control`, you can control<br/>
		/// whether a context performs this flush by setting the<br/>
		/// [GLFW_CONTEXT_RELEASE_BEHAVIOR](<br/>
		/// hint.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwMakeContextCurrent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MakeContextCurrent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window)
		{
			MakeContextCurrentNative(window);
		}

		/// <summary>
		/// <br/>
		/// This function makes the OpenGL or OpenGL ES context of the specified window<br/>
		/// current on the calling thread.  It can also detach the current context from<br/>
		/// the calling thread without making a new one current by passing in `NULL`.<br/>
		/// A context must only be made current on a single thread at a time and each<br/>
		/// thread can have only a single current context at a time.  Making a context<br/>
		/// current detaches any previously current context on the calling thread.<br/>
		/// When moving a context between threads, you must detach it (make it<br/>
		/// non-current) on the old thread before making it current on the new one.<br/>
		/// By default, making a context non-current implicitly forces a pipeline flush.<br/>
		/// On machines that support `GL_KHR_context_flush_control`, you can control<br/>
		/// whether a context performs this flush by setting the<br/>
		/// [GLFW_CONTEXT_RELEASE_BEHAVIOR](<br/>
		/// hint.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwMakeContextCurrent")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MakeContextCurrent([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				MakeContextCurrentNative((GLFWwindow*)pwindow);
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the window whose OpenGL or OpenGL ES context is<br/>
		/// current on the calling thread.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "GLFWwindow*")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLFWwindow* GetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*>)funcTable[113])();
			#else
			return (GLFWwindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[113])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the window whose OpenGL or OpenGL ES context is<br/>
		/// current on the calling thread.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetCurrentContext")]
		[return: NativeName(NativeNameType.Type, "GLFWwindow*")]
		public static GLFWwindow* GetCurrentContext()
		{
			GLFWwindow* ret = GetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function swaps the front and back buffers of the specified window when<br/>
		/// rendering with OpenGL or OpenGL ES.  If the swap interval is greater than<br/>
		/// zero, the GPU driver waits the specified number of screen updates before<br/>
		/// swapping the buffers.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see `vkQueuePresentKHR` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSwapBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SwapBuffersNative([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, void>)funcTable[114])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[114])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function swaps the front and back buffers of the specified window when<br/>
		/// rendering with OpenGL or OpenGL ES.  If the swap interval is greater than<br/>
		/// zero, the GPU driver waits the specified number of screen updates before<br/>
		/// swapping the buffers.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see `vkQueuePresentKHR` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSwapBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SwapBuffers([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] GLFWwindow* window)
		{
			SwapBuffersNative(window);
		}

		/// <summary>
		/// <br/>
		/// This function swaps the front and back buffers of the specified window when<br/>
		/// rendering with OpenGL or OpenGL ES.  If the swap interval is greater than<br/>
		/// zero, the GPU driver waits the specified number of screen updates before<br/>
		/// swapping the buffers.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see `vkQueuePresentKHR` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSwapBuffers")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SwapBuffers([NativeName(NativeNameType.Param, "window")] [NativeName(NativeNameType.Type, "GLFWwindow*")] ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				SwapBuffersNative((GLFWwindow*)pwindow);
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the swap interval for the current OpenGL or OpenGL ES<br/>
		/// context, i.e. the number of screen updates to wait from the time <br/>
		/// was called before swapping the buffers and returning.  This<br/>
		/// is sometimes called _vertical synchronization_, _vertical retrace<br/>
		/// synchronization_ or just _vsync_.<br/>
		/// A context that supports either of the `WGL_EXT_swap_control_tear` and<br/>
		/// `GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap<br/>
		/// intervals, which allows the driver to swap immediately even if a frame<br/>
		/// arrives a little bit late.  You can check for these extensions with <br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see the present mode of your swapchain instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSwapInterval")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SwapIntervalNative([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int")] int interval)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[115])(interval);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[115])(interval);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function sets the swap interval for the current OpenGL or OpenGL ES<br/>
		/// context, i.e. the number of screen updates to wait from the time <br/>
		/// was called before swapping the buffers and returning.  This<br/>
		/// is sometimes called _vertical synchronization_, _vertical retrace<br/>
		/// synchronization_ or just _vsync_.<br/>
		/// A context that supports either of the `WGL_EXT_swap_control_tear` and<br/>
		/// `GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap<br/>
		/// intervals, which allows the driver to swap immediately even if a frame<br/>
		/// arrives a little bit late.  You can check for these extensions with <br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see the present mode of your swapchain instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwSwapInterval")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SwapInterval([NativeName(NativeNameType.Param, "interval")] [NativeName(NativeNameType.Type, "int")] int interval)
		{
			SwapIntervalNative(interval);
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified<br/>
		/// [API extension](<br/>
		/// is supported by the current OpenGL or<br/>
		/// OpenGL ES context.  It searches both for client API extension and context<br/>
		/// creation API extensions.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// As this functions retrieves and searches one or more extension strings each<br/>
		/// call, it is recommended that you cache its results if it is going to be used<br/>
		/// frequently.  The extension strings will not change during the lifetime of<br/>
		/// a context, so there is no danger in doing this.<br/>
		/// This function does not apply to Vulkan.  If you are using Vulkan, see <br/>
		/// `vkEnumerateInstanceExtensionProperties`<br/>
		/// and `vkEnumerateDeviceExtensionProperties` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ExtensionSupportedNative([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] byte* extension)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[116])(extension);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[116])((nint)extension);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified<br/>
		/// [API extension](<br/>
		/// is supported by the current OpenGL or<br/>
		/// OpenGL ES context.  It searches both for client API extension and context<br/>
		/// creation API extensions.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// As this functions retrieves and searches one or more extension strings each<br/>
		/// call, it is recommended that you cache its results if it is going to be used<br/>
		/// frequently.  The extension strings will not change during the lifetime of<br/>
		/// a context, so there is no danger in doing this.<br/>
		/// This function does not apply to Vulkan.  If you are using Vulkan, see <br/>
		/// `vkEnumerateInstanceExtensionProperties`<br/>
		/// and `vkEnumerateDeviceExtensionProperties` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] byte* extension)
		{
			int ret = ExtensionSupportedNative(extension);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified<br/>
		/// [API extension](<br/>
		/// is supported by the current OpenGL or<br/>
		/// OpenGL ES context.  It searches both for client API extension and context<br/>
		/// creation API extensions.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// As this functions retrieves and searches one or more extension strings each<br/>
		/// call, it is recommended that you cache its results if it is going to be used<br/>
		/// frequently.  The extension strings will not change during the lifetime of<br/>
		/// a context, so there is no danger in doing this.<br/>
		/// This function does not apply to Vulkan.  If you are using Vulkan, see <br/>
		/// `vkEnumerateInstanceExtensionProperties`<br/>
		/// and `vkEnumerateDeviceExtensionProperties` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] ref byte extension)
		{
			fixed (byte* pextension = &extension)
			{
				int ret = ExtensionSupportedNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified<br/>
		/// [API extension](<br/>
		/// is supported by the current OpenGL or<br/>
		/// OpenGL ES context.  It searches both for client API extension and context<br/>
		/// creation API extensions.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// As this functions retrieves and searches one or more extension strings each<br/>
		/// call, it is recommended that you cache its results if it is going to be used<br/>
		/// frequently.  The extension strings will not change during the lifetime of<br/>
		/// a context, so there is no danger in doing this.<br/>
		/// This function does not apply to Vulkan.  If you are using Vulkan, see <br/>
		/// `vkEnumerateInstanceExtensionProperties`<br/>
		/// and `vkEnumerateDeviceExtensionProperties` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> extension)
		{
			fixed (byte* pextension = extension)
			{
				int ret = ExtensionSupportedNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified<br/>
		/// [API extension](<br/>
		/// is supported by the current OpenGL or<br/>
		/// OpenGL ES context.  It searches both for client API extension and context<br/>
		/// creation API extensions.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// As this functions retrieves and searches one or more extension strings each<br/>
		/// call, it is recommended that you cache its results if it is going to be used<br/>
		/// frequently.  The extension strings will not change during the lifetime of<br/>
		/// a context, so there is no danger in doing this.<br/>
		/// This function does not apply to Vulkan.  If you are using Vulkan, see <br/>
		/// `vkEnumerateInstanceExtensionProperties`<br/>
		/// and `vkEnumerateDeviceExtensionProperties` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwExtensionSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ExtensionSupported([NativeName(NativeNameType.Param, "extension")] [NativeName(NativeNameType.Type, "const char*")] string extension)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (extension != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(extension);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(extension, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ExtensionSupportedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the address of the specified OpenGL or OpenGL ES<br/>
		/// [core or extension function](<br/>
		/// if it is supported<br/>
		/// by the current context.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see <br/>
		/// `vkGetInstanceProcAddr` and<br/>
		/// `vkGetDeviceProcAddr` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned function pointer is valid until the context<br/>
		/// is destroyed or the library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetProcAddress")]
		[return: NativeName(NativeNameType.Type, "GLFWglproc")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> GetProcAddressNative([NativeName(NativeNameType.Param, "procname")] [NativeName(NativeNameType.Type, "const char*")] byte* procname)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void>>)funcTable[117])(procname);
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[117])((nint)procname);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the address of the specified OpenGL or OpenGL ES<br/>
		/// [core or extension function](<br/>
		/// if it is supported<br/>
		/// by the current context.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see <br/>
		/// `vkGetInstanceProcAddr` and<br/>
		/// `vkGetDeviceProcAddr` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned function pointer is valid until the context<br/>
		/// is destroyed or the library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetProcAddress")]
		[return: NativeName(NativeNameType.Type, "GLFWglproc")]
		public static delegate*<void> GetProcAddress([NativeName(NativeNameType.Param, "procname")] [NativeName(NativeNameType.Type, "const char*")] byte* procname)
		{
			delegate*<void> ret = GetProcAddressNative(procname);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the address of the specified OpenGL or OpenGL ES<br/>
		/// [core or extension function](<br/>
		/// if it is supported<br/>
		/// by the current context.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see <br/>
		/// `vkGetInstanceProcAddr` and<br/>
		/// `vkGetDeviceProcAddr` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned function pointer is valid until the context<br/>
		/// is destroyed or the library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetProcAddress")]
		[return: NativeName(NativeNameType.Type, "GLFWglproc")]
		public static delegate*<void> GetProcAddress([NativeName(NativeNameType.Param, "procname")] [NativeName(NativeNameType.Type, "const char*")] ref byte procname)
		{
			fixed (byte* pprocname = &procname)
			{
				delegate*<void> ret = GetProcAddressNative((byte*)pprocname);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the address of the specified OpenGL or OpenGL ES<br/>
		/// [core or extension function](<br/>
		/// if it is supported<br/>
		/// by the current context.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see <br/>
		/// `vkGetInstanceProcAddr` and<br/>
		/// `vkGetDeviceProcAddr` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned function pointer is valid until the context<br/>
		/// is destroyed or the library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetProcAddress")]
		[return: NativeName(NativeNameType.Type, "GLFWglproc")]
		public static delegate*<void> GetProcAddress([NativeName(NativeNameType.Param, "procname")] [NativeName(NativeNameType.Type, "const char*")] ReadOnlySpan<byte> procname)
		{
			fixed (byte* pprocname = procname)
			{
				delegate*<void> ret = GetProcAddressNative((byte*)pprocname);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the address of the specified OpenGL or OpenGL ES<br/>
		/// [core or extension function](<br/>
		/// if it is supported<br/>
		/// by the current context.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see <br/>
		/// `vkGetInstanceProcAddr` and<br/>
		/// `vkGetDeviceProcAddr` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned function pointer is valid until the context<br/>
		/// is destroyed or the library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetProcAddress")]
		[return: NativeName(NativeNameType.Type, "GLFWglproc")]
		public static delegate*<void> GetProcAddress([NativeName(NativeNameType.Param, "procname")] [NativeName(NativeNameType.Type, "const char*")] string procname)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (procname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(procname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(procname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			delegate*<void> ret = GetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the Vulkan loader and any minimally functional<br/>
		/// ICD have been found.<br/>
		/// The availability of a Vulkan loader and even an ICD does not by itself guarantee that<br/>
		/// surface creation or even instance creation is possible.  Call <br/>
		/// to check whether the extensions necessary for Vulkan<br/>
		/// surface creation are available and <br/>
		/// to<br/>
		/// check whether a queue family of a physical device supports image presentation.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwVulkanSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int VulkanSupportedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[118])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[118])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the Vulkan loader and any minimally functional<br/>
		/// ICD have been found.<br/>
		/// The availability of a Vulkan loader and even an ICD does not by itself guarantee that<br/>
		/// surface creation or even instance creation is possible.  Call <br/>
		/// to check whether the extensions necessary for Vulkan<br/>
		/// surface creation are available and <br/>
		/// to<br/>
		/// check whether a queue family of a physical device supports image presentation.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwVulkanSupported")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int VulkanSupported()
		{
			int ret = VulkanSupportedNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns an array of names of Vulkan instance extensions required<br/>
		/// by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the<br/>
		/// list will always contain `VK_KHR_surface`, so if you don't require any<br/>
		/// additional extensions you can pass this list directly to the<br/>
		/// `VkInstanceCreateInfo` struct.<br/>
		/// If Vulkan is not available on the machine, this function returns `NULL` and<br/>
		/// generates a <br/>
		/// error.  Call <br/>
		/// to check whether Vulkan is at least minimally available.<br/>
		/// If Vulkan is available but no set of extensions allowing window surface<br/>
		/// creation was found, this function returns `NULL`.  You may still use Vulkan<br/>
		/// for off-screen rendering and compute work.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is guaranteed to be valid only until the<br/>
		/// library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetRequiredInstanceExtensions")]
		[return: NativeName(NativeNameType.Type, "const char**")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte** GetRequiredInstanceExtensionsNative([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, byte**>)funcTable[119])(count);
			#else
			return (byte**)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[119])((nint)count);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns an array of names of Vulkan instance extensions required<br/>
		/// by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the<br/>
		/// list will always contain `VK_KHR_surface`, so if you don't require any<br/>
		/// additional extensions you can pass this list directly to the<br/>
		/// `VkInstanceCreateInfo` struct.<br/>
		/// If Vulkan is not available on the machine, this function returns `NULL` and<br/>
		/// generates a <br/>
		/// error.  Call <br/>
		/// to check whether Vulkan is at least minimally available.<br/>
		/// If Vulkan is available but no set of extensions allowing window surface<br/>
		/// creation was found, this function returns `NULL`.  You may still use Vulkan<br/>
		/// for off-screen rendering and compute work.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is guaranteed to be valid only until the<br/>
		/// library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetRequiredInstanceExtensions")]
		[return: NativeName(NativeNameType.Type, "const char**")]
		public static byte** GetRequiredInstanceExtensions([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "uint32_t*")] uint* count)
		{
			byte** ret = GetRequiredInstanceExtensionsNative(count);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns an array of names of Vulkan instance extensions required<br/>
		/// by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the<br/>
		/// list will always contain `VK_KHR_surface`, so if you don't require any<br/>
		/// additional extensions you can pass this list directly to the<br/>
		/// `VkInstanceCreateInfo` struct.<br/>
		/// If Vulkan is not available on the machine, this function returns `NULL` and<br/>
		/// generates a <br/>
		/// error.  Call <br/>
		/// to check whether Vulkan is at least minimally available.<br/>
		/// If Vulkan is available but no set of extensions allowing window surface<br/>
		/// creation was found, this function returns `NULL`.  You may still use Vulkan<br/>
		/// for off-screen rendering and compute work.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is guaranteed to be valid only until the<br/>
		/// library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "glfwGetRequiredInstanceExtensions")]
		[return: NativeName(NativeNameType.Type, "const char**")]
		public static byte** GetRequiredInstanceExtensions([NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "uint32_t*")] ref uint count)
		{
			fixed (uint* pcount = &count)
			{
				byte** ret = GetRequiredInstanceExtensionsNative((uint*)pcount);
				return ret;
			}
		}

	}
}
