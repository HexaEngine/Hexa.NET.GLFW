// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.GLFW
{
	public unsafe partial class GLFW
	{

		/// <summary>
		/// <br/>
		/// This function returns the current value of the user-defined pointer of the<br/>
		/// specified joystick.  The initial value is `NULL`.<br/>
		/// This function may be called from the joystick callback, even for a joystick<br/>
		/// that is being disconnected.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void* GetJoystickUserPointer(int jid)
		{
			void* ret = GetJoystickUserPointerNative(jid);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified joystick is both present and has<br/>
		/// a gamepad mapping.<br/>
		/// If the specified joystick is present but does not have a gamepad mapping<br/>
		/// this function will return `GLFW_FALSE` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check if a joystick is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int JoystickIsGamepadNative(int jid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[101])(jid);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[101])(jid);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified joystick is both present and has<br/>
		/// a gamepad mapping.<br/>
		/// If the specified joystick is present but does not have a gamepad mapping<br/>
		/// this function will return `GLFW_FALSE` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check if a joystick is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int JoystickIsGamepad(int jid)
		{
			int ret = JoystickIsGamepadNative(jid);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function sets the joystick configuration callback, or removes the<br/>
		/// currently set callback.  This is called when a joystick is connected to or<br/>
		/// disconnected from the system.<br/>
		/// For joystick connection and disconnection events to be delivered on all<br/>
		/// platforms, you need to call one of the [event processing](<br/>
		/// functions.  Joystick disconnection may also be detected and the callback<br/>
		/// called by joystick functions.  The function will then return whatever it<br/>
		/// returns if the joystick is not present.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// For more information about the callback parameters, see the<br/>
		/// [function pointer type](<br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<int, int, void> SetJoystickCallbackNative(GLFWjoystickfun callback)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<delegate*<int, int, void>, delegate*<int, int, void>>)funcTable[102])((delegate*<int, int, void>)Utils.GetFunctionPointerForDelegate(callback));
			#else
			return (delegate*<int, int, void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[102])((nint)Utils.GetFunctionPointerForDelegate(callback));
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function sets the joystick configuration callback, or removes the<br/>
		/// currently set callback.  This is called when a joystick is connected to or<br/>
		/// disconnected from the system.<br/>
		/// For joystick connection and disconnection events to be delivered on all<br/>
		/// platforms, you need to call one of the [event processing](<br/>
		/// functions.  Joystick disconnection may also be detected and the callback<br/>
		/// called by joystick functions.  The function will then return whatever it<br/>
		/// returns if the joystick is not present.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// For more information about the callback parameters, see the<br/>
		/// [function pointer type](<br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<int, int, void> SetJoystickCallback(GLFWjoystickfun callback)
		{
			delegate*<int, int, void> ret = SetJoystickCallbackNative(callback);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function parses the specified ASCII encoded string and updates the<br/>
		/// internal list with any gamepad mappings it finds.  This string may<br/>
		/// contain either a single gamepad mapping or many mappings separated by<br/>
		/// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`<br/>
		/// source file including empty lines and comments.<br/>
		/// See <br/>
		/// for a description of the format.<br/>
		/// If there is already a gamepad mapping for a given GUID in the internal list,<br/>
		/// it will be replaced by the one passed to this function.  If the library is<br/>
		/// terminated and re-initialized the internal list will revert to the built-in<br/>
		/// default.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int UpdateGamepadMappingsNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[103])(str);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[103])((nint)str);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function parses the specified ASCII encoded string and updates the<br/>
		/// internal list with any gamepad mappings it finds.  This string may<br/>
		/// contain either a single gamepad mapping or many mappings separated by<br/>
		/// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`<br/>
		/// source file including empty lines and comments.<br/>
		/// See <br/>
		/// for a description of the format.<br/>
		/// If there is already a gamepad mapping for a given GUID in the internal list,<br/>
		/// it will be replaced by the one passed to this function.  If the library is<br/>
		/// terminated and re-initialized the internal list will revert to the built-in<br/>
		/// default.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateGamepadMappings(byte* str)
		{
			int ret = UpdateGamepadMappingsNative(str);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function parses the specified ASCII encoded string and updates the<br/>
		/// internal list with any gamepad mappings it finds.  This string may<br/>
		/// contain either a single gamepad mapping or many mappings separated by<br/>
		/// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`<br/>
		/// source file including empty lines and comments.<br/>
		/// See <br/>
		/// for a description of the format.<br/>
		/// If there is already a gamepad mapping for a given GUID in the internal list,<br/>
		/// it will be replaced by the one passed to this function.  If the library is<br/>
		/// terminated and re-initialized the internal list will revert to the built-in<br/>
		/// default.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateGamepadMappings(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				int ret = UpdateGamepadMappingsNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function parses the specified ASCII encoded string and updates the<br/>
		/// internal list with any gamepad mappings it finds.  This string may<br/>
		/// contain either a single gamepad mapping or many mappings separated by<br/>
		/// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`<br/>
		/// source file including empty lines and comments.<br/>
		/// See <br/>
		/// for a description of the format.<br/>
		/// If there is already a gamepad mapping for a given GUID in the internal list,<br/>
		/// it will be replaced by the one passed to this function.  If the library is<br/>
		/// terminated and re-initialized the internal list will revert to the built-in<br/>
		/// default.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateGamepadMappings(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				int ret = UpdateGamepadMappingsNative((byte*)pstr);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function parses the specified ASCII encoded string and updates the<br/>
		/// internal list with any gamepad mappings it finds.  This string may<br/>
		/// contain either a single gamepad mapping or many mappings separated by<br/>
		/// newlines.  The parser supports the full format of the `gamecontrollerdb.txt`<br/>
		/// source file including empty lines and comments.<br/>
		/// See <br/>
		/// for a description of the format.<br/>
		/// If there is already a gamepad mapping for a given GUID in the internal list,<br/>
		/// it will be replaced by the one passed to this function.  If the library is<br/>
		/// terminated and re-initialized the internal list will revert to the built-in<br/>
		/// default.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int UpdateGamepadMappings(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = UpdateGamepadMappingsNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the human-readable name of the gamepad from the<br/>
		/// gamepad mapping assigned to the specified joystick.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `NULL` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected, the gamepad mappings are updated or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetGamepadNameNative(int jid)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*>)funcTable[104])(jid);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<int, nint>)funcTable[104])(jid);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the human-readable name of the gamepad from the<br/>
		/// gamepad mapping assigned to the specified joystick.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `NULL` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected, the gamepad mappings are updated or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetGamepadName(int jid)
		{
			byte* ret = GetGamepadNameNative(jid);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the human-readable name of the gamepad from the<br/>
		/// gamepad mapping assigned to the specified joystick.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `NULL` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the specified joystick is<br/>
		/// disconnected, the gamepad mappings are updated or the library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetGamepadNameS(int jid)
		{
			string ret = Utils.DecodeStringUTF8(GetGamepadNameNative(jid));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function retrieves the state of the specified joystick remapped to<br/>
		/// an Xbox-like gamepad.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `GLFW_FALSE` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// The Guide button may not be available for input as it is often hooked by the<br/>
		/// system or the Steam client.<br/>
		/// Not all devices have all the buttons or axes provided by <br/>
		/// Unavailable buttons and axes will always report<br/>
		/// `GLFW_RELEASE` and 0.0 respectively.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetGamepadStateNative(int jid, GLFWgamepadstate* state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, GLFWgamepadstate*, int>)funcTable[105])(jid, state);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, nint, int>)funcTable[105])(jid, (nint)state);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function retrieves the state of the specified joystick remapped to<br/>
		/// an Xbox-like gamepad.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `GLFW_FALSE` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// The Guide button may not be available for input as it is often hooked by the<br/>
		/// system or the Steam client.<br/>
		/// Not all devices have all the buttons or axes provided by <br/>
		/// Unavailable buttons and axes will always report<br/>
		/// `GLFW_RELEASE` and 0.0 respectively.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetGamepadState(int jid, GLFWgamepadstatePtr state)
		{
			int ret = GetGamepadStateNative(jid, state);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function retrieves the state of the specified joystick remapped to<br/>
		/// an Xbox-like gamepad.<br/>
		/// If the specified joystick is not present or does not have a gamepad mapping<br/>
		/// this function will return `GLFW_FALSE` but will not generate an error.  Call<br/>
		/// <br/>
		/// to check whether it is present regardless of<br/>
		/// whether it has a mapping.<br/>
		/// The Guide button may not be available for input as it is often hooked by the<br/>
		/// system or the Steam client.<br/>
		/// Not all devices have all the buttons or axes provided by <br/>
		/// Unavailable buttons and axes will always report<br/>
		/// `GLFW_RELEASE` and 0.0 respectively.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetGamepadState(int jid, ref GLFWgamepadstate state)
		{
			fixed (GLFWgamepadstate* pstate = &state)
			{
				int ret = GetGamepadStateNative(jid, (GLFWgamepadstate*)pstate);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetClipboardStringNative(GLFWwindow* window, byte* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, byte*, void>)funcTable[106])(window, str);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[106])((nint)window, (nint)str);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetClipboardString(GLFWwindowPtr window, byte* str)
		{
			SetClipboardStringNative(window, str);
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetClipboardString(ref GLFWwindow window, byte* str)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				SetClipboardStringNative((GLFWwindow*)pwindow, str);
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetClipboardString(GLFWwindowPtr window, ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				SetClipboardStringNative(window, (byte*)pstr);
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetClipboardString(GLFWwindowPtr window, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SetClipboardStringNative(window, (byte*)pstr);
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetClipboardString(GLFWwindowPtr window, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetClipboardStringNative(window, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetClipboardString(ref GLFWwindow window, ref byte str)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (byte* pstr = &str)
				{
					SetClipboardStringNative((GLFWwindow*)pwindow, (byte*)pstr);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetClipboardString(ref GLFWwindow window, ReadOnlySpan<byte> str)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (byte* pstr = str)
				{
					SetClipboardStringNative((GLFWwindow*)pwindow, (byte*)pstr);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the system clipboard to the specified, UTF-8 encoded<br/>
		/// string.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetClipboardString(ref GLFWwindow window, string str)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (str != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(str);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				SetClipboardStringNative((GLFWwindow*)pwindow, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the contents of the system clipboard, if it contains<br/>
		/// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or<br/>
		/// if its contents cannot be converted, `NULL` is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the next call to <br/>
		/// or <br/>
		/// or until the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetClipboardStringNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, byte*>)funcTable[107])(window);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[107])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the contents of the system clipboard, if it contains<br/>
		/// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or<br/>
		/// if its contents cannot be converted, `NULL` is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the next call to <br/>
		/// or <br/>
		/// or until the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetClipboardString(GLFWwindowPtr window)
		{
			byte* ret = GetClipboardStringNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the contents of the system clipboard, if it contains<br/>
		/// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or<br/>
		/// if its contents cannot be converted, `NULL` is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the next call to <br/>
		/// or <br/>
		/// or until the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetClipboardStringS(GLFWwindowPtr window)
		{
			string ret = Utils.DecodeStringUTF8(GetClipboardStringNative(window));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the contents of the system clipboard, if it contains<br/>
		/// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or<br/>
		/// if its contents cannot be converted, `NULL` is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the next call to <br/>
		/// or <br/>
		/// or until the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetClipboardString(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				byte* ret = GetClipboardStringNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the contents of the system clipboard, if it contains<br/>
		/// or is convertible to a UTF-8 encoded string.  If the clipboard is empty or<br/>
		/// if its contents cannot be converted, `NULL` is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is valid until the next call to <br/>
		/// or <br/>
		/// or until the library<br/>
		/// is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetClipboardStringS(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				string ret = Utils.DecodeStringUTF8(GetClipboardStringNative((GLFWwindow*)pwindow));
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the current GLFW time, in seconds.  Unless the time<br/>
		/// has been set using <br/>
		/// it measures time elapsed since GLFW was<br/>
		/// initialized.<br/>
		/// This function and <br/>
		/// are helper functions on top of <br/>
		/// and <br/>
		/// The resolution of the timer is system dependent, but is usually on the order<br/>
		/// of a few micro- or nanoseconds.  It uses the highest-resolution monotonic<br/>
		/// time source on each operating system.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Reading and<br/>
		/// writing of the internal base time is not atomic, so it needs to be<br/>
		/// externally synchronized with calls to <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static double GetTimeNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<double>)funcTable[108])();
			#else
			return (double)((delegate* unmanaged[Cdecl]<double>)funcTable[108])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the current GLFW time, in seconds.  Unless the time<br/>
		/// has been set using <br/>
		/// it measures time elapsed since GLFW was<br/>
		/// initialized.<br/>
		/// This function and <br/>
		/// are helper functions on top of <br/>
		/// and <br/>
		/// The resolution of the timer is system dependent, but is usually on the order<br/>
		/// of a few micro- or nanoseconds.  It uses the highest-resolution monotonic<br/>
		/// time source on each operating system.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Reading and<br/>
		/// writing of the internal base time is not atomic, so it needs to be<br/>
		/// externally synchronized with calls to <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static double GetTime()
		{
			double ret = GetTimeNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function sets the current GLFW time, in seconds.  The value must be<br/>
		/// a positive finite number less than or equal to 18446744073.0, which is<br/>
		/// approximately 584.5 years.<br/>
		/// This function and <br/>
		/// are helper functions on top of <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Reading and<br/>
		/// writing of the internal base time is not atomic, so it needs to be<br/>
		/// externally synchronized with calls to <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetTimeNative(double time)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[109])(time);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[109])(time);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function sets the current GLFW time, in seconds.  The value must be<br/>
		/// a positive finite number less than or equal to 18446744073.0, which is<br/>
		/// approximately 584.5 years.<br/>
		/// This function and <br/>
		/// are helper functions on top of <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Reading and<br/>
		/// writing of the internal base time is not atomic, so it needs to be<br/>
		/// externally synchronized with calls to <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetTime(double time)
		{
			SetTimeNative(time);
		}

		/// <summary>
		/// <br/>
		/// This function returns the current value of the raw timer, measured in<br/>
		/// 1<br/>
		/// <br/>
		/// /<br/>
		/// <br/>
		/// frequency seconds.  To get the frequency, call <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTimerValueNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[110])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[110])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the current value of the raw timer, measured in<br/>
		/// 1<br/>
		/// <br/>
		/// /<br/>
		/// <br/>
		/// frequency seconds.  To get the frequency, call <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GetTimerValue()
		{
			ulong ret = GetTimerValueNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the frequency, in Hz, of the raw timer.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTimerFrequencyNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong>)funcTable[111])();
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ulong>)funcTable[111])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the frequency, in Hz, of the raw timer.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static ulong GetTimerFrequency()
		{
			ulong ret = GetTimerFrequencyNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function makes the OpenGL or OpenGL ES context of the specified window<br/>
		/// current on the calling thread.  It can also detach the current context from<br/>
		/// the calling thread without making a new one current by passing in `NULL`.<br/>
		/// A context must only be made current on a single thread at a time and each<br/>
		/// thread can have only a single current context at a time.  Making a context<br/>
		/// current detaches any previously current context on the calling thread.<br/>
		/// When moving a context between threads, you must detach it (make it<br/>
		/// non-current) on the old thread before making it current on the new one.<br/>
		/// By default, making a context non-current implicitly forces a pipeline flush.<br/>
		/// On machines that support `GL_KHR_context_flush_control`, you can control<br/>
		/// whether a context performs this flush by setting the<br/>
		/// [GLFW_CONTEXT_RELEASE_BEHAVIOR](<br/>
		/// hint.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeContextCurrentNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, void>)funcTable[112])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[112])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function makes the OpenGL or OpenGL ES context of the specified window<br/>
		/// current on the calling thread.  It can also detach the current context from<br/>
		/// the calling thread without making a new one current by passing in `NULL`.<br/>
		/// A context must only be made current on a single thread at a time and each<br/>
		/// thread can have only a single current context at a time.  Making a context<br/>
		/// current detaches any previously current context on the calling thread.<br/>
		/// When moving a context between threads, you must detach it (make it<br/>
		/// non-current) on the old thread before making it current on the new one.<br/>
		/// By default, making a context non-current implicitly forces a pipeline flush.<br/>
		/// On machines that support `GL_KHR_context_flush_control`, you can control<br/>
		/// whether a context performs this flush by setting the<br/>
		/// [GLFW_CONTEXT_RELEASE_BEHAVIOR](<br/>
		/// hint.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MakeContextCurrent(GLFWwindowPtr window)
		{
			MakeContextCurrentNative(window);
		}

		/// <summary>
		/// <br/>
		/// This function makes the OpenGL or OpenGL ES context of the specified window<br/>
		/// current on the calling thread.  It can also detach the current context from<br/>
		/// the calling thread without making a new one current by passing in `NULL`.<br/>
		/// A context must only be made current on a single thread at a time and each<br/>
		/// thread can have only a single current context at a time.  Making a context<br/>
		/// current detaches any previously current context on the calling thread.<br/>
		/// When moving a context between threads, you must detach it (make it<br/>
		/// non-current) on the old thread before making it current on the new one.<br/>
		/// By default, making a context non-current implicitly forces a pipeline flush.<br/>
		/// On machines that support `GL_KHR_context_flush_control`, you can control<br/>
		/// whether a context performs this flush by setting the<br/>
		/// [GLFW_CONTEXT_RELEASE_BEHAVIOR](<br/>
		/// hint.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void MakeContextCurrent(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				MakeContextCurrentNative((GLFWwindow*)pwindow);
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the window whose OpenGL or OpenGL ES context is<br/>
		/// current on the calling thread.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLFWwindow* GetCurrentContextNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*>)funcTable[113])();
			#else
			return (GLFWwindow*)((delegate* unmanaged[Cdecl]<nint>)funcTable[113])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the window whose OpenGL or OpenGL ES context is<br/>
		/// current on the calling thread.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static GLFWwindowPtr GetCurrentContext()
		{
			GLFWwindowPtr ret = GetCurrentContextNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function swaps the front and back buffers of the specified window when<br/>
		/// rendering with OpenGL or OpenGL ES.  If the swap interval is greater than<br/>
		/// zero, the GPU driver waits the specified number of screen updates before<br/>
		/// swapping the buffers.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see `vkQueuePresentKHR` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SwapBuffersNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFWwindow*, void>)funcTable[114])(window);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[114])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function swaps the front and back buffers of the specified window when<br/>
		/// rendering with OpenGL or OpenGL ES.  If the swap interval is greater than<br/>
		/// zero, the GPU driver waits the specified number of screen updates before<br/>
		/// swapping the buffers.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see `vkQueuePresentKHR` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SwapBuffers(GLFWwindowPtr window)
		{
			SwapBuffersNative(window);
		}

		/// <summary>
		/// <br/>
		/// This function swaps the front and back buffers of the specified window when<br/>
		/// rendering with OpenGL or OpenGL ES.  If the swap interval is greater than<br/>
		/// zero, the GPU driver waits the specified number of screen updates before<br/>
		/// swapping the buffers.<br/>
		/// The specified window must have an OpenGL or OpenGL ES context.  Specifying<br/>
		/// a window without a context will generate a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see `vkQueuePresentKHR` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SwapBuffers(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				SwapBuffersNative((GLFWwindow*)pwindow);
			}
		}

		/// <summary>
		/// <br/>
		/// This function sets the swap interval for the current OpenGL or OpenGL ES<br/>
		/// context, i.e. the number of screen updates to wait from the time <br/>
		/// was called before swapping the buffers and returning.  This<br/>
		/// is sometimes called _vertical synchronization_, _vertical retrace<br/>
		/// synchronization_ or just _vsync_.<br/>
		/// A context that supports either of the `WGL_EXT_swap_control_tear` and<br/>
		/// `GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap<br/>
		/// intervals, which allows the driver to swap immediately even if a frame<br/>
		/// arrives a little bit late.  You can check for these extensions with <br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see the present mode of your swapchain instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SwapIntervalNative(int interval)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[115])(interval);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[115])(interval);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function sets the swap interval for the current OpenGL or OpenGL ES<br/>
		/// context, i.e. the number of screen updates to wait from the time <br/>
		/// was called before swapping the buffers and returning.  This<br/>
		/// is sometimes called _vertical synchronization_, _vertical retrace<br/>
		/// synchronization_ or just _vsync_.<br/>
		/// A context that supports either of the `WGL_EXT_swap_control_tear` and<br/>
		/// `GLX_EXT_swap_control_tear` extensions also accepts _negative_ swap<br/>
		/// intervals, which allows the driver to swap immediately even if a frame<br/>
		/// arrives a little bit late.  You can check for these extensions with <br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see the present mode of your swapchain instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SwapInterval(int interval)
		{
			SwapIntervalNative(interval);
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified<br/>
		/// [API extension](<br/>
		/// is supported by the current OpenGL or<br/>
		/// OpenGL ES context.  It searches both for client API extension and context<br/>
		/// creation API extensions.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// As this functions retrieves and searches one or more extension strings each<br/>
		/// call, it is recommended that you cache its results if it is going to be used<br/>
		/// frequently.  The extension strings will not change during the lifetime of<br/>
		/// a context, so there is no danger in doing this.<br/>
		/// This function does not apply to Vulkan.  If you are using Vulkan, see <br/>
		/// `vkEnumerateInstanceExtensionProperties`<br/>
		/// and `vkEnumerateDeviceExtensionProperties` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ExtensionSupportedNative(byte* extension)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int>)funcTable[116])(extension);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[116])((nint)extension);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified<br/>
		/// [API extension](<br/>
		/// is supported by the current OpenGL or<br/>
		/// OpenGL ES context.  It searches both for client API extension and context<br/>
		/// creation API extensions.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// As this functions retrieves and searches one or more extension strings each<br/>
		/// call, it is recommended that you cache its results if it is going to be used<br/>
		/// frequently.  The extension strings will not change during the lifetime of<br/>
		/// a context, so there is no danger in doing this.<br/>
		/// This function does not apply to Vulkan.  If you are using Vulkan, see <br/>
		/// `vkEnumerateInstanceExtensionProperties`<br/>
		/// and `vkEnumerateDeviceExtensionProperties` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ExtensionSupported(byte* extension)
		{
			int ret = ExtensionSupportedNative(extension);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified<br/>
		/// [API extension](<br/>
		/// is supported by the current OpenGL or<br/>
		/// OpenGL ES context.  It searches both for client API extension and context<br/>
		/// creation API extensions.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// As this functions retrieves and searches one or more extension strings each<br/>
		/// call, it is recommended that you cache its results if it is going to be used<br/>
		/// frequently.  The extension strings will not change during the lifetime of<br/>
		/// a context, so there is no danger in doing this.<br/>
		/// This function does not apply to Vulkan.  If you are using Vulkan, see <br/>
		/// `vkEnumerateInstanceExtensionProperties`<br/>
		/// and `vkEnumerateDeviceExtensionProperties` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ExtensionSupported(ref byte extension)
		{
			fixed (byte* pextension = &extension)
			{
				int ret = ExtensionSupportedNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified<br/>
		/// [API extension](<br/>
		/// is supported by the current OpenGL or<br/>
		/// OpenGL ES context.  It searches both for client API extension and context<br/>
		/// creation API extensions.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// As this functions retrieves and searches one or more extension strings each<br/>
		/// call, it is recommended that you cache its results if it is going to be used<br/>
		/// frequently.  The extension strings will not change during the lifetime of<br/>
		/// a context, so there is no danger in doing this.<br/>
		/// This function does not apply to Vulkan.  If you are using Vulkan, see <br/>
		/// `vkEnumerateInstanceExtensionProperties`<br/>
		/// and `vkEnumerateDeviceExtensionProperties` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ExtensionSupported(ReadOnlySpan<byte> extension)
		{
			fixed (byte* pextension = extension)
			{
				int ret = ExtensionSupportedNative((byte*)pextension);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the specified<br/>
		/// [API extension](<br/>
		/// is supported by the current OpenGL or<br/>
		/// OpenGL ES context.  It searches both for client API extension and context<br/>
		/// creation API extensions.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// As this functions retrieves and searches one or more extension strings each<br/>
		/// call, it is recommended that you cache its results if it is going to be used<br/>
		/// frequently.  The extension strings will not change during the lifetime of<br/>
		/// a context, so there is no danger in doing this.<br/>
		/// This function does not apply to Vulkan.  If you are using Vulkan, see <br/>
		/// `vkEnumerateInstanceExtensionProperties`<br/>
		/// and `vkEnumerateDeviceExtensionProperties` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int ExtensionSupported(string extension)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (extension != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(extension);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(extension, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ExtensionSupportedNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the address of the specified OpenGL or OpenGL ES<br/>
		/// [core or extension function](<br/>
		/// if it is supported<br/>
		/// by the current context.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see <br/>
		/// `vkGetInstanceProcAddr` and<br/>
		/// `vkGetDeviceProcAddr` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned function pointer is valid until the context<br/>
		/// is destroyed or the library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static delegate*<void> GetProcAddressNative(byte* procname)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, delegate*<void>>)funcTable[117])(procname);
			#else
			return (delegate*<void>)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[117])((nint)procname);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns the address of the specified OpenGL or OpenGL ES<br/>
		/// [core or extension function](<br/>
		/// if it is supported<br/>
		/// by the current context.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see <br/>
		/// `vkGetInstanceProcAddr` and<br/>
		/// `vkGetDeviceProcAddr` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned function pointer is valid until the context<br/>
		/// is destroyed or the library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> GetProcAddress(byte* procname)
		{
			delegate*<void> ret = GetProcAddressNative(procname);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns the address of the specified OpenGL or OpenGL ES<br/>
		/// [core or extension function](<br/>
		/// if it is supported<br/>
		/// by the current context.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see <br/>
		/// `vkGetInstanceProcAddr` and<br/>
		/// `vkGetDeviceProcAddr` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned function pointer is valid until the context<br/>
		/// is destroyed or the library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> GetProcAddress(ref byte procname)
		{
			fixed (byte* pprocname = &procname)
			{
				delegate*<void> ret = GetProcAddressNative((byte*)pprocname);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the address of the specified OpenGL or OpenGL ES<br/>
		/// [core or extension function](<br/>
		/// if it is supported<br/>
		/// by the current context.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see <br/>
		/// `vkGetInstanceProcAddr` and<br/>
		/// `vkGetDeviceProcAddr` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned function pointer is valid until the context<br/>
		/// is destroyed or the library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> GetProcAddress(ReadOnlySpan<byte> procname)
		{
			fixed (byte* pprocname = procname)
			{
				delegate*<void> ret = GetProcAddressNative((byte*)pprocname);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// This function returns the address of the specified OpenGL or OpenGL ES<br/>
		/// [core or extension function](<br/>
		/// if it is supported<br/>
		/// by the current context.<br/>
		/// A context must be current on the calling thread.  Calling this function<br/>
		/// without a current context will cause a <br/>
		/// error.<br/>
		/// This function does not apply to Vulkan.  If you are rendering with Vulkan,<br/>
		/// see <br/>
		/// `vkGetInstanceProcAddr` and<br/>
		/// `vkGetDeviceProcAddr` instead.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned function pointer is valid until the context<br/>
		/// is destroyed or the library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static delegate*<void> GetProcAddress(string procname)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (procname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(procname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(procname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			delegate*<void> ret = GetProcAddressNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the Vulkan loader and any minimally functional<br/>
		/// ICD have been found.<br/>
		/// The availability of a Vulkan loader and even an ICD does not by itself guarantee that<br/>
		/// surface creation or even instance creation is possible.  Call <br/>
		/// to check whether the extensions necessary for Vulkan<br/>
		/// surface creation are available and <br/>
		/// to<br/>
		/// check whether a queue family of a physical device supports image presentation.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int VulkanSupportedNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)funcTable[118])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)funcTable[118])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns whether the Vulkan loader and any minimally functional<br/>
		/// ICD have been found.<br/>
		/// The availability of a Vulkan loader and even an ICD does not by itself guarantee that<br/>
		/// surface creation or even instance creation is possible.  Call <br/>
		/// to check whether the extensions necessary for Vulkan<br/>
		/// surface creation are available and <br/>
		/// to<br/>
		/// check whether a queue family of a physical device supports image presentation.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int VulkanSupported()
		{
			int ret = VulkanSupportedNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns an array of names of Vulkan instance extensions required<br/>
		/// by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the<br/>
		/// list will always contain `VK_KHR_surface`, so if you don't require any<br/>
		/// additional extensions you can pass this list directly to the<br/>
		/// `VkInstanceCreateInfo` struct.<br/>
		/// If Vulkan is not available on the machine, this function returns `NULL` and<br/>
		/// generates a <br/>
		/// error.  Call <br/>
		/// to check whether Vulkan is at least minimally available.<br/>
		/// If Vulkan is available but no set of extensions allowing window surface<br/>
		/// creation was found, this function returns `NULL`.  You may still use Vulkan<br/>
		/// for off-screen rendering and compute work.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is guaranteed to be valid only until the<br/>
		/// library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte** GetRequiredInstanceExtensionsNative(uint* count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, byte**>)funcTable[119])(count);
			#else
			return (byte**)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[119])((nint)count);
			#endif
		}

		/// <summary>
		/// <br/>
		/// This function returns an array of names of Vulkan instance extensions required<br/>
		/// by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the<br/>
		/// list will always contain `VK_KHR_surface`, so if you don't require any<br/>
		/// additional extensions you can pass this list directly to the<br/>
		/// `VkInstanceCreateInfo` struct.<br/>
		/// If Vulkan is not available on the machine, this function returns `NULL` and<br/>
		/// generates a <br/>
		/// error.  Call <br/>
		/// to check whether Vulkan is at least minimally available.<br/>
		/// If Vulkan is available but no set of extensions allowing window surface<br/>
		/// creation was found, this function returns `NULL`.  You may still use Vulkan<br/>
		/// for off-screen rendering and compute work.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is guaranteed to be valid only until the<br/>
		/// library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte** GetRequiredInstanceExtensions(uint* count)
		{
			byte** ret = GetRequiredInstanceExtensionsNative(count);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// This function returns an array of names of Vulkan instance extensions required<br/>
		/// by GLFW for creating Vulkan surfaces for GLFW windows.  If successful, the<br/>
		/// list will always contain `VK_KHR_surface`, so if you don't require any<br/>
		/// additional extensions you can pass this list directly to the<br/>
		/// `VkInstanceCreateInfo` struct.<br/>
		/// If Vulkan is not available on the machine, this function returns `NULL` and<br/>
		/// generates a <br/>
		/// error.  Call <br/>
		/// to check whether Vulkan is at least minimally available.<br/>
		/// If Vulkan is available but no set of extensions allowing window surface<br/>
		/// creation was found, this function returns `NULL`.  You may still use Vulkan<br/>
		/// for off-screen rendering and compute work.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// <br/>
		/// _lifetime The returned array is allocated and freed by GLFW.  You<br/>
		/// should not free it yourself.  It is guaranteed to be valid only until the<br/>
		/// library is terminated.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte** GetRequiredInstanceExtensions(ref uint count)
		{
			fixed (uint* pcount = &count)
			{
				byte** ret = GetRequiredInstanceExtensionsNative((uint*)pcount);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetWin32AdapterNative(GLFWmonitor* monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWmonitor*, byte*>)funcTable[120])(monitor);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[120])((nint)monitor);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetWin32Adapter(GLFWmonitorPtr monitor)
		{
			byte* ret = GetWin32AdapterNative(monitor);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetWin32AdapterS(GLFWmonitorPtr monitor)
		{
			string ret = Utils.DecodeStringUTF8(GetWin32AdapterNative(monitor));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetWin32Adapter(ref GLFWmonitor monitor)
		{
			fixed (GLFWmonitor* pmonitor = &monitor)
			{
				byte* ret = GetWin32AdapterNative((GLFWmonitor*)pmonitor);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetWin32AdapterS(ref GLFWmonitor monitor)
		{
			fixed (GLFWmonitor* pmonitor = &monitor)
			{
				string ret = Utils.DecodeStringUTF8(GetWin32AdapterNative((GLFWmonitor*)pmonitor));
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetWin32MonitorNative(GLFWmonitor* monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWmonitor*, byte*>)funcTable[121])(monitor);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[121])((nint)monitor);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetWin32Monitor(GLFWmonitorPtr monitor)
		{
			byte* ret = GetWin32MonitorNative(monitor);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetWin32MonitorS(GLFWmonitorPtr monitor)
		{
			string ret = Utils.DecodeStringUTF8(GetWin32MonitorNative(monitor));
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetWin32Monitor(ref GLFWmonitor monitor)
		{
			fixed (GLFWmonitor* pmonitor = &monitor)
			{
				byte* ret = GetWin32MonitorNative((GLFWmonitor*)pmonitor);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetWin32MonitorS(ref GLFWmonitor monitor)
		{
			fixed (GLFWmonitor* pmonitor = &monitor)
			{
				string ret = Utils.DecodeStringUTF8(GetWin32MonitorNative((GLFWmonitor*)pmonitor));
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// This DC is private and does not need to be released.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nint GetWin32WindowNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, nint>)funcTable[122])(window);
			#else
			return (nint)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[122])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// This DC is private and does not need to be released.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nint GetWin32Window(GLFWwindowPtr window)
		{
			nint ret = GetWin32WindowNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// This DC is private and does not need to be released.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static nint GetWin32Window(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				nint ret = GetWin32WindowNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// This DC is private and does not need to be released.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Hglrc GetWGLContextNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, Hglrc>)funcTable[123])(window);
			#else
			return (Hglrc)((delegate* unmanaged[Cdecl]<nint, Hglrc>)funcTable[123])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// This DC is private and does not need to be released.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Hglrc GetWGLContext(GLFWwindowPtr window)
		{
			Hglrc ret = GetWGLContextNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// This DC is private and does not need to be released.<br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Hglrc GetWGLContext(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				Hglrc ret = GetWGLContextNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetCocoaMonitorNative(GLFWmonitor* monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWmonitor*, uint>)funcTable[124])(monitor);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<nint, uint>)funcTable[124])((nint)monitor);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetCocoaMonitor(GLFWmonitorPtr monitor)
		{
			uint ret = GetCocoaMonitorNative(monitor);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static uint GetCocoaMonitor(ref GLFWmonitor monitor)
		{
			fixed (GLFWmonitor* pmonitor = &monitor)
			{
				uint ret = GetCocoaMonitorNative((GLFWmonitor*)pmonitor);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Id GetCocoaWindowNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, Id>)funcTable[125])(window);
			#else
			return (Id)((delegate* unmanaged[Cdecl]<nint, Id>)funcTable[125])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Id GetCocoaWindow(GLFWwindowPtr window)
		{
			Id ret = GetCocoaWindowNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Id GetCocoaWindow(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				Id ret = GetCocoaWindowNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Id GetCocoaViewNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, Id>)funcTable[126])(window);
			#else
			return (Id)((delegate* unmanaged[Cdecl]<nint, Id>)funcTable[126])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Id GetCocoaView(GLFWwindowPtr window)
		{
			Id ret = GetCocoaViewNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Id GetCocoaView(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				Id ret = GetCocoaViewNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Id GetNSGLContextNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, Id>)funcTable[127])(window);
			#else
			return (Id)((delegate* unmanaged[Cdecl]<nint, Id>)funcTable[127])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Id GetNSGLContext(GLFWwindowPtr window)
		{
			Id ret = GetNSGLContextNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static Id GetNSGLContext(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				Id ret = GetNSGLContextNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static X11Display* GetX11DisplayNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<X11Display*>)funcTable[128])();
			#else
			return (X11Display*)((delegate* unmanaged[Cdecl]<nint>)funcTable[128])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static X11Display* GetX11Display()
		{
			X11Display* ret = GetX11DisplayNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static RRCrtc GetX11AdapterNative(GLFWmonitor* monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWmonitor*, RRCrtc>)funcTable[129])(monitor);
			#else
			return (RRCrtc)((delegate* unmanaged[Cdecl]<nint, RRCrtc>)funcTable[129])((nint)monitor);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static RRCrtc GetX11Adapter(GLFWmonitorPtr monitor)
		{
			RRCrtc ret = GetX11AdapterNative(monitor);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static RRCrtc GetX11Adapter(ref GLFWmonitor monitor)
		{
			fixed (GLFWmonitor* pmonitor = &monitor)
			{
				RRCrtc ret = GetX11AdapterNative((GLFWmonitor*)pmonitor);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static RROutput GetX11MonitorNative(GLFWmonitor* monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWmonitor*, RROutput>)funcTable[130])(monitor);
			#else
			return (RROutput)((delegate* unmanaged[Cdecl]<nint, RROutput>)funcTable[130])((nint)monitor);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static RROutput GetX11Monitor(GLFWmonitorPtr monitor)
		{
			RROutput ret = GetX11MonitorNative(monitor);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static RROutput GetX11Monitor(ref GLFWmonitor monitor)
		{
			fixed (GLFWmonitor* pmonitor = &monitor)
			{
				RROutput ret = GetX11MonitorNative((GLFWmonitor*)pmonitor);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static X11Window GetX11WindowNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, X11Window>)funcTable[131])(window);
			#else
			return (X11Window)((delegate* unmanaged[Cdecl]<nint, X11Window>)funcTable[131])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static X11Window GetX11Window(GLFWwindowPtr window)
		{
			X11Window ret = GetX11WindowNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static X11Window GetX11Window(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				X11Window ret = GetX11WindowNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetX11SelectionStringNative(byte* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[132])(str);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[132])((nint)str);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetX11SelectionString(byte* str)
		{
			SetX11SelectionStringNative(str);
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetX11SelectionString(ref byte str)
		{
			fixed (byte* pstr = &str)
			{
				SetX11SelectionStringNative((byte*)pstr);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetX11SelectionString(ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr = str)
			{
				SetX11SelectionStringNative((byte*)pstr);
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The specified string is copied before this function<br/>
		/// returns.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static void SetX11SelectionString(string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SetX11SelectionStringNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// <br/>
		/// If the selection is empty or if its contents cannot be converted, `NULL`<br/>
		/// is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW. You<br/>
		/// should not free it yourself. It is valid until the next call to <br/>
		/// or <br/>
		/// or until the<br/>
		/// library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetX11SelectionStringNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*>)funcTable[133])();
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint>)funcTable[133])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// If the selection is empty or if its contents cannot be converted, `NULL`<br/>
		/// is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW. You<br/>
		/// should not free it yourself. It is valid until the next call to <br/>
		/// or <br/>
		/// or until the<br/>
		/// library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static byte* GetX11SelectionString()
		{
			byte* ret = GetX11SelectionStringNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// If the selection is empty or if its contents cannot be converted, `NULL`<br/>
		/// is returned and a <br/>
		/// error is generated.<br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _lifetime The returned string is allocated and freed by GLFW. You<br/>
		/// should not free it yourself. It is valid until the next call to <br/>
		/// or <br/>
		/// or until the<br/>
		/// library is terminated.<br/>
		/// <br/>
		/// _safety This function must only be called from the main thread.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static string GetX11SelectionStringS()
		{
			string ret = Utils.DecodeStringUTF8(GetX11SelectionStringNative());
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLXContext GetGLXContextNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, GLXContext>)funcTable[134])(window);
			#else
			return (GLXContext)((delegate* unmanaged[Cdecl]<nint, GLXContext>)funcTable[134])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static GLXContext GetGLXContext(GLFWwindowPtr window)
		{
			GLXContext ret = GetGLXContextNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static GLXContext GetGLXContext(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				GLXContext ret = GetGLXContextNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLXWindow GetGLXWindowNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, GLXWindow>)funcTable[135])(window);
			#else
			return (GLXWindow)((delegate* unmanaged[Cdecl]<nint, GLXWindow>)funcTable[135])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static GLXWindow GetGLXWindow(GLFWwindowPtr window)
		{
			GLXWindow ret = GetGLXWindowNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static GLXWindow GetGLXWindow(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				GLXWindow ret = GetGLXWindowNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static WlDisplay* GetWaylandDisplayNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<WlDisplay*>)funcTable[136])();
			#else
			return (WlDisplay*)((delegate* unmanaged[Cdecl]<nint>)funcTable[136])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static WlDisplayPtr GetWaylandDisplay()
		{
			WlDisplayPtr ret = GetWaylandDisplayNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static WlOutput* GetWaylandMonitorNative(GLFWmonitor* monitor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWmonitor*, WlOutput*>)funcTable[137])(monitor);
			#else
			return (WlOutput*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[137])((nint)monitor);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static WlOutputPtr GetWaylandMonitor(GLFWmonitorPtr monitor)
		{
			WlOutputPtr ret = GetWaylandMonitorNative(monitor);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static WlOutputPtr GetWaylandMonitor(ref GLFWmonitor monitor)
		{
			fixed (GLFWmonitor* pmonitor = &monitor)
			{
				WlOutputPtr ret = GetWaylandMonitorNative((GLFWmonitor*)pmonitor);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static WlSurface* GetWaylandWindowNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, WlSurface*>)funcTable[138])(window);
			#else
			return (WlSurface*)((delegate* unmanaged[Cdecl]<nint, nint>)funcTable[138])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static WlSurfacePtr GetWaylandWindow(GLFWwindowPtr window)
		{
			WlSurfacePtr ret = GetWaylandWindowNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static WlSurfacePtr GetWaylandWindow(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				WlSurfacePtr ret = GetWaylandWindowNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLDisplay GetEGLDisplayNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<EGLDisplay>)funcTable[139])();
			#else
			return (EGLDisplay)((delegate* unmanaged[Cdecl]<EGLDisplay>)funcTable[139])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static EGLDisplay GetEGLDisplay()
		{
			EGLDisplay ret = GetEGLDisplayNative();
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLContext GetEGLContextNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, EGLContext>)funcTable[140])(window);
			#else
			return (EGLContext)((delegate* unmanaged[Cdecl]<nint, EGLContext>)funcTable[140])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static EGLContext GetEGLContext(GLFWwindowPtr window)
		{
			EGLContext ret = GetEGLContextNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static EGLContext GetEGLContext(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				EGLContext ret = GetEGLContextNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static EGLSurface GetEGLSurfaceNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, EGLSurface>)funcTable[141])(window);
			#else
			return (EGLSurface)((delegate* unmanaged[Cdecl]<nint, EGLSurface>)funcTable[141])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static EGLSurface GetEGLSurface(GLFWwindowPtr window)
		{
			EGLSurface ret = GetEGLSurfaceNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static EGLSurface GetEGLSurface(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				EGLSurface ret = GetEGLSurfaceNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetOSMesaColorBufferNative(GLFWwindow* window, int* width, int* height, int* format, void** buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, int*, int*, int*, void**, int>)funcTable[142])(window, width, height, format, buffer);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int>)funcTable[142])((nint)window, (nint)width, (nint)height, (nint)format, (nint)buffer);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(GLFWwindowPtr window, int* width, int* height, int* format, void** buffer)
		{
			int ret = GetOSMesaColorBufferNative(window, width, height, format, buffer);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(ref GLFWwindow window, int* width, int* height, int* format, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				int ret = GetOSMesaColorBufferNative((GLFWwindow*)pwindow, width, height, format, buffer);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(GLFWwindowPtr window, ref int width, int* height, int* format, void** buffer)
		{
			fixed (int* pwidth = &width)
			{
				int ret = GetOSMesaColorBufferNative(window, (int*)pwidth, height, format, buffer);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(ref GLFWwindow window, ref int width, int* height, int* format, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pwidth = &width)
				{
					int ret = GetOSMesaColorBufferNative((GLFWwindow*)pwindow, (int*)pwidth, height, format, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(GLFWwindowPtr window, int* width, ref int height, int* format, void** buffer)
		{
			fixed (int* pheight = &height)
			{
				int ret = GetOSMesaColorBufferNative(window, width, (int*)pheight, format, buffer);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(ref GLFWwindow window, int* width, ref int height, int* format, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pheight = &height)
				{
					int ret = GetOSMesaColorBufferNative((GLFWwindow*)pwindow, width, (int*)pheight, format, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(GLFWwindowPtr window, ref int width, ref int height, int* format, void** buffer)
		{
			fixed (int* pwidth = &width)
			{
				fixed (int* pheight = &height)
				{
					int ret = GetOSMesaColorBufferNative(window, (int*)pwidth, (int*)pheight, format, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(ref GLFWwindow window, ref int width, ref int height, int* format, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pwidth = &width)
				{
					fixed (int* pheight = &height)
					{
						int ret = GetOSMesaColorBufferNative((GLFWwindow*)pwindow, (int*)pwidth, (int*)pheight, format, buffer);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(GLFWwindowPtr window, int* width, int* height, ref int format, void** buffer)
		{
			fixed (int* pformat = &format)
			{
				int ret = GetOSMesaColorBufferNative(window, width, height, (int*)pformat, buffer);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(ref GLFWwindow window, int* width, int* height, ref int format, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pformat = &format)
				{
					int ret = GetOSMesaColorBufferNative((GLFWwindow*)pwindow, width, height, (int*)pformat, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(GLFWwindowPtr window, ref int width, int* height, ref int format, void** buffer)
		{
			fixed (int* pwidth = &width)
			{
				fixed (int* pformat = &format)
				{
					int ret = GetOSMesaColorBufferNative(window, (int*)pwidth, height, (int*)pformat, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(ref GLFWwindow window, ref int width, int* height, ref int format, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pwidth = &width)
				{
					fixed (int* pformat = &format)
					{
						int ret = GetOSMesaColorBufferNative((GLFWwindow*)pwindow, (int*)pwidth, height, (int*)pformat, buffer);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(GLFWwindowPtr window, int* width, ref int height, ref int format, void** buffer)
		{
			fixed (int* pheight = &height)
			{
				fixed (int* pformat = &format)
				{
					int ret = GetOSMesaColorBufferNative(window, width, (int*)pheight, (int*)pformat, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(ref GLFWwindow window, int* width, ref int height, ref int format, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pheight = &height)
				{
					fixed (int* pformat = &format)
					{
						int ret = GetOSMesaColorBufferNative((GLFWwindow*)pwindow, width, (int*)pheight, (int*)pformat, buffer);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(GLFWwindowPtr window, ref int width, ref int height, ref int format, void** buffer)
		{
			fixed (int* pwidth = &width)
			{
				fixed (int* pheight = &height)
				{
					fixed (int* pformat = &format)
					{
						int ret = GetOSMesaColorBufferNative(window, (int*)pwidth, (int*)pheight, (int*)pformat, buffer);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaColorBuffer(ref GLFWwindow window, ref int width, ref int height, ref int format, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pwidth = &width)
				{
					fixed (int* pheight = &height)
					{
						fixed (int* pformat = &format)
						{
							int ret = GetOSMesaColorBufferNative((GLFWwindow*)pwindow, (int*)pwidth, (int*)pheight, (int*)pformat, buffer);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetOSMesaDepthBufferNative(GLFWwindow* window, int* width, int* height, int* bytesPerValue, void** buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, int*, int*, int*, void**, int>)funcTable[143])(window, width, height, bytesPerValue, buffer);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, nint, int>)funcTable[143])((nint)window, (nint)width, (nint)height, (nint)bytesPerValue, (nint)buffer);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(GLFWwindowPtr window, int* width, int* height, int* bytesPerValue, void** buffer)
		{
			int ret = GetOSMesaDepthBufferNative(window, width, height, bytesPerValue, buffer);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(ref GLFWwindow window, int* width, int* height, int* bytesPerValue, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				int ret = GetOSMesaDepthBufferNative((GLFWwindow*)pwindow, width, height, bytesPerValue, buffer);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(GLFWwindowPtr window, ref int width, int* height, int* bytesPerValue, void** buffer)
		{
			fixed (int* pwidth = &width)
			{
				int ret = GetOSMesaDepthBufferNative(window, (int*)pwidth, height, bytesPerValue, buffer);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(ref GLFWwindow window, ref int width, int* height, int* bytesPerValue, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pwidth = &width)
				{
					int ret = GetOSMesaDepthBufferNative((GLFWwindow*)pwindow, (int*)pwidth, height, bytesPerValue, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(GLFWwindowPtr window, int* width, ref int height, int* bytesPerValue, void** buffer)
		{
			fixed (int* pheight = &height)
			{
				int ret = GetOSMesaDepthBufferNative(window, width, (int*)pheight, bytesPerValue, buffer);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(ref GLFWwindow window, int* width, ref int height, int* bytesPerValue, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pheight = &height)
				{
					int ret = GetOSMesaDepthBufferNative((GLFWwindow*)pwindow, width, (int*)pheight, bytesPerValue, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(GLFWwindowPtr window, ref int width, ref int height, int* bytesPerValue, void** buffer)
		{
			fixed (int* pwidth = &width)
			{
				fixed (int* pheight = &height)
				{
					int ret = GetOSMesaDepthBufferNative(window, (int*)pwidth, (int*)pheight, bytesPerValue, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(ref GLFWwindow window, ref int width, ref int height, int* bytesPerValue, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pwidth = &width)
				{
					fixed (int* pheight = &height)
					{
						int ret = GetOSMesaDepthBufferNative((GLFWwindow*)pwindow, (int*)pwidth, (int*)pheight, bytesPerValue, buffer);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(GLFWwindowPtr window, int* width, int* height, ref int bytesPerValue, void** buffer)
		{
			fixed (int* pbytesPerValue = &bytesPerValue)
			{
				int ret = GetOSMesaDepthBufferNative(window, width, height, (int*)pbytesPerValue, buffer);
				return ret;
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(ref GLFWwindow window, int* width, int* height, ref int bytesPerValue, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pbytesPerValue = &bytesPerValue)
				{
					int ret = GetOSMesaDepthBufferNative((GLFWwindow*)pwindow, width, height, (int*)pbytesPerValue, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(GLFWwindowPtr window, ref int width, int* height, ref int bytesPerValue, void** buffer)
		{
			fixed (int* pwidth = &width)
			{
				fixed (int* pbytesPerValue = &bytesPerValue)
				{
					int ret = GetOSMesaDepthBufferNative(window, (int*)pwidth, height, (int*)pbytesPerValue, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(ref GLFWwindow window, ref int width, int* height, ref int bytesPerValue, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pwidth = &width)
				{
					fixed (int* pbytesPerValue = &bytesPerValue)
					{
						int ret = GetOSMesaDepthBufferNative((GLFWwindow*)pwindow, (int*)pwidth, height, (int*)pbytesPerValue, buffer);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(GLFWwindowPtr window, int* width, ref int height, ref int bytesPerValue, void** buffer)
		{
			fixed (int* pheight = &height)
			{
				fixed (int* pbytesPerValue = &bytesPerValue)
				{
					int ret = GetOSMesaDepthBufferNative(window, width, (int*)pheight, (int*)pbytesPerValue, buffer);
					return ret;
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(ref GLFWwindow window, int* width, ref int height, ref int bytesPerValue, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pheight = &height)
				{
					fixed (int* pbytesPerValue = &bytesPerValue)
					{
						int ret = GetOSMesaDepthBufferNative((GLFWwindow*)pwindow, width, (int*)pheight, (int*)pbytesPerValue, buffer);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(GLFWwindowPtr window, ref int width, ref int height, ref int bytesPerValue, void** buffer)
		{
			fixed (int* pwidth = &width)
			{
				fixed (int* pheight = &height)
				{
					fixed (int* pbytesPerValue = &bytesPerValue)
					{
						int ret = GetOSMesaDepthBufferNative(window, (int*)pwidth, (int*)pheight, (int*)pbytesPerValue, buffer);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static int GetOSMesaDepthBuffer(ref GLFWwindow window, ref int width, ref int height, ref int bytesPerValue, void** buffer)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				fixed (int* pwidth = &width)
				{
					fixed (int* pheight = &height)
					{
						fixed (int* pbytesPerValue = &bytesPerValue)
						{
							int ret = GetOSMesaDepthBufferNative((GLFWwindow*)pwindow, (int*)pwidth, (int*)pheight, (int*)pbytesPerValue, buffer);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static OSMesaContext GetOSMesaContextNative(GLFWwindow* window)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFWwindow*, OSMesaContext>)funcTable[144])(window);
			#else
			return (OSMesaContext)((delegate* unmanaged[Cdecl]<nint, OSMesaContext>)funcTable[144])((nint)window);
			#endif
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static OSMesaContext GetOSMesaContext(GLFWwindowPtr window)
		{
			OSMesaContext ret = GetOSMesaContextNative(window);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// <br/>
		/// <br/>
		/// Possible errors include <br/>
		/// and <br/>
		/// <br/>
		/// _safety This function may be called from any thread.  Access is not<br/>
		/// synchronized.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		public static OSMesaContext GetOSMesaContext(ref GLFWwindow window)
		{
			fixed (GLFWwindow* pwindow = &window)
			{
				OSMesaContext ret = GetOSMesaContextNative((GLFWwindow*)pwindow);
				return ret;
			}
		}

	}
}
